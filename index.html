<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>StaricBoll - 3D –®—É—Ç–µ—Ä –æ—Ç –ø–µ—Ä–≤–æ–≥–æ –ª–∏—Ü–∞</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: 'Segoe UI', Arial, sans-serif;
            background-color: #121212;
            color: white;
        }
        canvas {
            display: block;
        }
        #loader {
            position: fixed;
            width: 100%;
            height: 100%;
            top: 0;
            left: 0;
            background-color: #121212;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            opacity: 1;
            transition: opacity 1s ease-out;
        }
        #loader h1 {
            font-size: 72px;
            color: #fff;
            text-shadow: 0 0 20px rgba(79, 220, 255, 0.7);
            letter-spacing: 5px;
            margin-bottom: 50px;
            opacity: 0;
            transform: translateY(30px);
            animation: fadeInUp 1.5s ease forwards 0.5s;
        }
        @keyframes fadeInUp {
            from {
                opacity: 0;
                transform: translateY(30px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }
        .loader-bar {
            width: 300px;
            height: 4px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 4px;
            overflow: hidden;
            position: relative;
            margin-top: 20px;
        }
        .loader-progress {
            position: absolute;
            top: 0;
            left: 0;
            height: 100%;
            width: 0%;
            background: linear-gradient(90deg, #4FDCFF, #7165FF);
            border-radius: 4px;
            transition: width 0.5s ease;
            animation: loadProgress 3s ease forwards;
        }
        @keyframes loadProgress {
            0% { width: 0%; }
            100% { width: 100%; }
        }
        #code-check {
            position: fixed;
            width: 100%;
            height: 100%;
            top: 0;
            left: 0;
            background-color: #121212;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 999;
            opacity: 0;
            transform: scale(0.98);
            transition: opacity 0.7s ease, transform 0.7s ease;
        }
        #code-check.active {
            opacity: 1;
            transform: scale(1);
        }
        #code-check h2 {
            font-size: 36px;
            color: #fff;
            text-shadow: 0 0 10px rgba(79, 220, 255, 0.5);
            letter-spacing: 2px;
            margin-bottom: 30px;
            text-align: center;
        }
        #code-form {
            display: flex;
            flex-direction: column;
            align-items: center;
            width: 100%;
            max-width: 400px;
        }
        .code-input-container {
            display: flex;
            justify-content: center;
            gap: 10px;
            margin-bottom: 20px;
            width: 100%;
        }
        .code-digit {
            width: 50px;
            height: 60px;
            background-color: rgba(255, 255, 255, 0.05);
            border: 2px solid rgba(79, 220, 255, 0.3);
            border-radius: 8px;
            color: white;
            font-size: 24px;
            text-align: center;
            transition: all 0.3s ease;
        }
        .code-digit:focus {
            outline: none;
            border-color: #4FDCFF;
            box-shadow: 0 0 15px rgba(79, 220, 255, 0.5);
        }
        #submit-code {
            background: linear-gradient(90deg, #4FDCFF, #7165FF);
            color: white;
            border: none;
            padding: 12px 40px;
            font-size: 18px;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            margin-top: 20px;
            width: 100%;
            max-width: 300px;
            letter-spacing: 1px;
            font-weight: 600;
        }
        #submit-code:hover {
            transform: translateY(-3px);
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.3);
        }
        #submit-code:active {
            transform: translateY(0);
        }
        #error-message {
            color: #ff5555;
            margin-top: 20px;
            font-size: 16px;
            height: 20px;
            text-align: center;
            transition: opacity 0.3s ease;
            opacity: 0;
        }
        #help-link {
            color: rgba(79, 220, 255, 0.7);
            margin-top: 30px;
            font-size: 16px;
            text-decoration: underline;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        #help-link:hover {
            color: #4FDCFF;
        }
        #instructions {
            position: fixed;
            width: 100%;
            height: 100%;
            top: 0;
            left: 0;
            background-color: rgba(18, 18, 18, 0.95);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 1001;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.5s ease;
            padding: 20px;
        }
        #instructions.active {
            opacity: 1;
            pointer-events: auto;
        }
        .instructions-container {
            background-color: #1c1c1c;
            border-radius: 15px;
            padding: 30px;
            max-width: 500px;
            width: 90%;
            box-shadow: 0 15px 40px rgba(0, 0, 0, 0.5);
            position: relative;
            transform: translateY(30px);
            opacity: 0;
            transition: transform 0.5s ease, opacity 0.5s ease;
        }
        #instructions.active .instructions-container {
            transform: translateY(0);
            opacity: 1;
        }
        .instructions-container h3 {
            color: #4FDCFF;
            font-size: 24px;
            margin-bottom: 20px;
            text-align: center;
        }
        .instructions-container p {
            margin-bottom: 15px;
            line-height: 1.6;
        }
        .instructions-container ol {
            padding-left: 20px;
        }
        .instructions-container ol li {
            margin-bottom: 15px;
            line-height: 1.6;
        }
        #close-instructions {
            position: absolute;
            top: 15px;
            right: 15px;
            background: none;
            border: none;
            color: rgba(255, 255, 255, 0.7);
            font-size: 24px;
            cursor: pointer;
            transition: color 0.3s ease;
        }
        #close-instructions:hover {
            color: white;
        }
        #hud {
            position: absolute;
            top: 20px;
            left: 20px;
            color: white;
            font-size: 18px;
            text-shadow: 1px 1px 2px black;
            pointer-events: none;
        }
        #health-bar {
            width: 200px;
            height: 20px;
            background-color: rgba(51, 51, 51, 0.7);
            margin-top: 10px;
            border-radius: 10px;
            overflow: hidden;
        }
        #health-fill {
            width: 100%;
            height: 100%;
            background-color: #0f0;
            transition: width 0.3s;
        }
        #ammo {
            margin-top: 10px;
        }
        #crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: rgba(255, 255, 255, 0.8);
            font-size: 24px;
            text-align: center;
            line-height: 20px;
            pointer-events: none;
            text-shadow: 0 0 5px rgba(0, 0, 0, 0.5);
        }
        #game-over, #level-up {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 36px;
            text-align: center;
            background-color: rgba(0, 0, 0, 0.8);
            padding: 30px;
            border-radius: 15px;
            display: none;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
        }
        button {
            background-color: #4CAF50;
            border: none;
            color: white;
            padding: 12px 24px;
            text-align: center;
            text-decoration: none;
            display: inline-block;
            font-size: 18px;
            margin: 15px 5px;
            cursor: pointer;
            border-radius: 8px;
            transition: background-color 0.3s;
        }
        button:hover {
            background-color: #3e8e41;
        }
        #device-selection {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.9);
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            animation: fadeIn 1.2s ease-out;
        }
        @keyframes fadeIn {
            0% { opacity: 0; }
            100% { opacity: 1; }
        }
        #device-selection h1 {
            font-size: 48px;
            margin-bottom: 50px;
            text-align: center;
            color: #fff;
            text-shadow: 0 0 10px rgba(255, 255, 255, 0.5);
            animation: titlePulse 2s infinite;
            letter-spacing: 2px;
        }
        @keyframes titlePulse {
            0% { text-shadow: 0 0 10px rgba(255, 255, 255, 0.5); }
            50% { text-shadow: 0 0 20px rgba(255, 255, 255, 0.8), 0 0 30px rgba(79, 220, 255, 0.6); }
            100% { text-shadow: 0 0 10px rgba(255, 255, 255, 0.5); }
        }
        .device-buttons {
            display: flex;
            gap: 40px;
            animation: slideUp 0.8s ease-out 0.4s both;
            flex-direction: row;
        }
        @media (max-width: 768px) {
            .device-buttons {
                flex-direction: column;
            }
        }
        @keyframes slideUp {
            0% { transform: translateY(50px); opacity: 0; }
            100% { transform: translateY(0); opacity: 1; }
        }
        .device-button {
            background: linear-gradient(145deg, #4FDCFF, #7165FF);
            color: white;
            border: none;
            padding: 20px 40px;
            font-size: 22px;
            border-radius: 15px;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3), 
                        0 0 0 rgba(79, 220, 255, 0.4);
            position: relative;
            overflow: hidden;
            letter-spacing: 1px;
            font-weight: bold;
            text-transform: uppercase;
        }
        .device-button:before {
            content: '';
            position: absolute;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: radial-gradient(circle, rgba(255, 255, 255, 0.3) 0%, transparent 60%);
            transform: rotate(45deg);
            opacity: 0;
            transition: opacity 0.3s;
        }
        .device-button:hover {
            transform: translateY(-5px) scale(1.05);
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.5), 
                        0 0 20px rgba(79, 220, 255, 0.6);
            background: linear-gradient(145deg, #5de2ff, #8370ff);
        }
        .device-button:hover:before {
            opacity: 1;
            animation: shine 1.5s infinite;
        }
        @keyframes shine {
            0% { opacity: 0.5; }
            50% { opacity: 0.8; }
            100% { opacity: 0.5; }
        }
        .device-button:active {
            transform: translateY(0) scale(0.98);
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);
        }
        #mobile-controls {
            position: absolute;
            bottom: 20px;
            left: 0;
            width: 100%;
            display: none;
            pointer-events: none;
        }
        .joystick-area {
            position: absolute;
            bottom: 20px;
            left: 20px;
            width: 120px;
            height: 120px;
            background-color: rgba(255, 255, 255, 0.2);
            border-radius: 60px;
            pointer-events: auto;
        }
        .joystick {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 60px;
            height: 60px;
            background-color: rgba(255, 255, 255, 0.5);
            border-radius: 30px;
        }
        .action-buttons {
            position: absolute;
            bottom: 20px;
            right: 20px;
            display: flex;
            flex-direction: column;
            gap: 10px;
            pointer-events: auto;
        }
        .action-button {
            width: 60px;
            height: 60px;
            background-color: rgba(255, 255, 255, 0.2);
            border-radius: 30px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 20px;
            color: white;
        }
        .look-area {
            position: absolute;
            top: 0;
            right: 0;
            width: 100%;
            height: 100%;
            pointer-events: auto;
        }
        #reload-indicator {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 10px 20px;
            border-radius: 5px;
            display: none;
            pointer-events: none;
        }
        #hit-marker {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: red;
            font-size: 40px;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.1s;
        }
    </style>
</head>
<body>
    <!-- Loading Screen -->
    <div id="loader">
        <h1>StaricBoll</h1>
        <div class="loader-bar">
            <div class="loader-progress"></div>
        </div>
    </div>

    <!-- Code Check Screen -->
    <div id="code-check">
        <h2>–í–≤–µ–¥–∏—Ç–µ –∫–æ–¥ –¥–æ—Å—Ç—É–ø–∞</h2>
        <form id="code-form">
            <div class="code-input-container">
                <input type="text" class="code-digit" maxlength="1" pattern="[0-9]" required>
                <input type="text" class="code-digit" maxlength="1" pattern="[0-9]" required>
                <input type="text" class="code-digit" maxlength="1" pattern="[0-9]" required>
                <input type="text" class="code-digit" maxlength="1" pattern="[0-9]" required>
                <input type="text" class="code-digit" maxlength="1" pattern="[0-9]" required>
                <input type="text" class="code-digit" maxlength="1" pattern="[0-9]" required>
            </div>
            <button type="submit" id="submit-code">–í–æ–π—Ç–∏</button>
        </form>
        <div id="error-message"></div>
        <div id="help-link">–ö–∞–∫ –º–Ω–µ –ø–æ–ª—É—á–∏—Ç—å –∫–æ–¥?</div>
    </div>

    <!-- Instructions Modal -->
    <div id="instructions">
        <div class="instructions-container">
            <button id="close-instructions">√ó</button>
            <h3>–ö–∞–∫ –ø–æ–ª—É—á–∏—Ç—å –∫–æ–¥ –¥–æ—Å—Ç—É–ø–∞</h3>
            <ol>
                <li>–í–∞–º –Ω—É–∂–Ω–æ –ø–µ—Ä–µ–π—Ç–∏ –Ω–∞ —Å–∞–π—Ç <a href="https://www.donationalerts.com/r/andrey291414" target="_blank" style="color: #4FDCFF;">donationalerts.com/r/andrey291414</a> –∏ –æ–ø–ª–∞—Ç–∏—Ç—å 99 –†—É–±–ª–µ–π. –ï—Å–ª–∏ —É –≤–∞—Å —É–∫–∞–∑–∞–Ω—ã –ï–≤—Ä–æ, —Ç–æ –ø–æ–º–µ–Ω—è–π—Ç–µ –∏—Ö –Ω–∞ –†—É–±–ª–∏.</li>
                <li><strong>–í–ê–ñ–ù–û:</strong> –ö–æ–≥–¥–∞ –≤—ã –ø–µ—Ä–µ–π–¥–µ—Ç–µ –ø–æ —Å—Å—ã–ª–∫–µ, —Ç–∞–º –±—É–¥–µ—Ç –æ–±—è–∑–∞—Ç–µ–ª—å–Ω–∞—è –∏–Ω—Å—Ç—Ä—É–∫—Ü–∏—è —á—Ç–æ –∏ –∫–∞–∫. <strong>–ü–†–û–ß–¢–ò–¢–ï –ï–ï –û–ë–Ø–ó–ê–¢–ï–õ–¨–ù–û!!!</strong></li>
                <li>–ü–æ—Å–ª–µ –ø–æ–∫—É–ø–∫–∏ –Ω–∞ –≤–∞—à—É –ø–æ—á—Ç—É –ø–æ—Å—Ç—É–ø–∏—Ç 6-–∑–Ω–∞—á–Ω—ã–π –∫–æ–¥. –ï–≥–æ –Ω—É–∂–Ω–æ –±—É–¥–µ—Ç –≤–≤–µ—Å—Ç–∏ –≤ –ø–æ–ª–µ –¥–ª—è –≤–≤–æ–¥–∞ –∫–æ–¥–∞, –∏ —Ç–æ–≥–¥–∞ –≤—ã –ø–æ–ø–∞–¥–µ—Ç–µ –≤ –∏–≥—Ä—É, –∏ –≤–∞–º –±–æ–ª—å—à–µ –æ–ø–ª–∞—á–∏–≤–∞—Ç—å –¥–æ—Å—Ç—É–ø –±—É–¥–µ—Ç –Ω–µ –Ω—É–∂–Ω–æ.</li>
            </ol>
            <p>–í—ã –ø–æ–∫—É–ø–∞–µ—Ç–µ –∏–≥—Ä—É –Ω–∞ –≤—Å—é –∂–∏–∑–Ω—å –Ω–∞ —ç—Ç–æ–º IP –∞–¥—Ä–µ—Å–µ. –ü–æ—Å–ª–µ –ø–æ–∫—É–ø–∫–∏ –∏ –≤–≤–µ–¥–µ–Ω–∏—è –∫–æ–¥–∞ –≤–∞–º –Ω–µ –Ω—É–∂–Ω–æ –±—É–¥–µ—Ç –µ–≥–æ –±–æ–ª—å—à–µ –≤–≤–æ–¥–∏—Ç—å –Ω–∞ —ç—Ç–æ–º —É—Å—Ç—Ä–æ–π—Å—Ç–≤–µ.</p>
        </div>
    </div>

    <div id="device-selection">
        <h1>–í—ã–±–µ—Ä–∏—Ç–µ —É—Å—Ç—Ä–æ–π—Å—Ç–≤–æ</h1>
        <div class="device-buttons">
            <button class="device-button" id="pc-button">–ö–æ–º–ø—å—é—Ç–µ—Ä / –ù–æ—É—Ç–±—É–∫</button>
            <button class="device-button" id="mobile-button">–¢–µ–ª–µ—Ñ–æ–Ω / –ü–ª–∞–Ω—à–µ—Ç</button>
        </div>
    </div>

    <div id="hud">
        <div>–£—Ä–æ–≤–µ–Ω—å: <span id="level">1</span></div>
        <div>–û—á–∫–∏: <span id="score">0</span></div>
        <div>–ó–¥–æ—Ä–æ–≤—å–µ:</div>
        <div id="health-bar"><div id="health-fill"></div></div>
        <div id="ammo">–ü–∞—Ç—Ä–æ–Ω—ã: <span id="ammo-count">30</span> / <span id="max-ammo">30</span></div>
    </div>
    <div id="crosshair">+</div>
    <div id="hit-marker">√ó</div>
    <div id="reload-indicator">–ü–µ—Ä–µ–∑–∞—Ä—è–¥–∫–∞...</div>
    <div id="game-over">
        <h2>–ò–≥—Ä–∞ –æ–∫–æ–Ω—á–µ–Ω–∞</h2>
        <p>–í–∞—à —Å—á–µ—Ç: <span id="final-score">0</span></p>
        <button id="restart-button">–ù–∞—á–∞—Ç—å –∑–∞–Ω–æ–≤–æ</button>
    </div>
    <div id="level-up">
        <h2>–£—Ä–æ–≤–µ–Ω—å –ø—Ä–æ–π–¥–µ–Ω!</h2>
        <p>–ü–µ—Ä–µ—Ö–æ–¥ –Ω–∞ —É—Ä–æ–≤–µ–Ω—å <span id="new-level">2</span></p>
        <button id="next-level-button">–ü—Ä–æ–¥–æ–ª–∂–∏—Ç—å</button>
    </div>

    <div id="mobile-controls">
        <div class="joystick-area">
            <div class="joystick" id="joystick"></div>
        </div>
        <div class="look-area" id="look-area"></div>
        <div class="action-buttons">
            <div class="action-button" id="shoot-button">üî´</div>
            <div class="action-button" id="jump-button">‚Üë</div>
            <div class="action-button" id="reload-button">‚Üª</div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // –û–±—Ä–∞–±–æ—Ç–∫–∞ –∑–∞–≥—Ä—É–∑–æ—á–Ω–æ–≥–æ —ç–∫—Ä–∞–Ω–∞ –∏ –ø—Ä–æ–≤–µ—Ä–∫–∏ –∫–æ–¥–∞
        document.addEventListener('DOMContentLoaded', function() {
            // –ê–Ω–∏–º–∞—Ü–∏—è –∑–∞–≥—Ä—É–∑–æ—á–Ω–æ–≥–æ —ç–∫—Ä–∞–Ω–∞
            setTimeout(function() {
                document.getElementById('loader').style.opacity = '0';
                setTimeout(function() {
                    document.getElementById('loader').style.display = 'none';
                    document.getElementById('code-check').classList.add('active');
                }, 1000);
            }, 3000);

            // –ù–∞—Å—Ç—Ä–æ–π–∫–∞ —Ñ–æ—Ä–º—ã –≤–≤–æ–¥–∞ –∫–æ–¥–∞
            const codeInputs = document.querySelectorAll('.code-digit');
            const form = document.getElementById('code-form');
            const errorMessage = document.getElementById('error-message');
            
            // –û–±—Ä–∞–±–æ—Ç–∫–∞ –∞–≤—Ç–æ–ø–µ—Ä–µ—Ö–æ–¥–∞ –º–µ–∂–¥—É –ø–æ–ª—è–º–∏ –≤–≤–æ–¥–∞
            codeInputs.forEach((input, index) => {
                input.addEventListener('input', function() {
                    if (this.value && index < codeInputs.length - 1) {
                        codeInputs[index + 1].focus();
                    }
                });
                
                input.addEventListener('keydown', function(e) {
                    if (e.key === 'Backspace' && !this.value && index > 0) {
                        codeInputs[index - 1].focus();
                    }
                });
            });
            
            // –ü—Ä–æ–≤–µ—Ä–∫–∞ –∫–æ–¥–∞ –ø—Ä–∏ –æ—Ç–ø—Ä–∞–≤–∫–µ —Ñ–æ—Ä–º—ã
            form.addEventListener('submit', function(e) {
                e.preventDefault();
                
                let code = '';
                codeInputs.forEach(input => {
                    code += input.value;
                });
                
                // –ü—Ä–æ–≤–µ—Ä–∫–∞ –∫–æ–¥–∞ - 291414
                checkCode(code);
            });
            
            // –û–±—Ä–∞–±–æ—Ç–∫–∞ —Å—Å—ã–ª–∫–∏ –ø–æ–º–æ—â–∏
            document.getElementById('help-link').addEventListener('click', function() {
                document.getElementById('instructions').classList.add('active');
            });
            
            // –ó–∞–∫—Ä—ã—Ç–∏–µ –∏–Ω—Å—Ç—Ä—É–∫—Ü–∏–π
            document.getElementById('close-instructions').addEventListener('click', function() {
                document.getElementById('instructions').classList.remove('active');
            });
            
            // –§—É–Ω–∫—Ü–∏—è –¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏ –∫–æ–¥–∞
            function checkCode(code) {
                // –ü—Ä–æ–≤–µ—Ä—è–µ–º –∫–æ–¥ –±–µ–∑ –ø—Ä—è–º–æ–≥–æ —É–∫–∞–∑–∞–Ω–∏—è –≤ –∏—Å—Ö–æ–¥–Ω–æ–º –∫–æ–¥–µ
                const correctCode = atob('MjkxNDE0'); // –ó–∞–∫–æ–¥–∏—Ä–æ–≤–∞–Ω–Ω—ã–π –∫–æ–¥ –≤ base64
                
                if (code === correctCode) {
                    // –°–æ—Ö—Ä–∞–Ω—è–µ–º –≤ localStorage –ø—Ä–∏–∑–Ω–∞–∫ —Ç–æ–≥–æ, —á—Ç–æ –∫–æ–¥ –±—ã–ª –≤–≤–µ–¥–µ–Ω
                    localStorage.setItem('gameAccess', 'true');
                    
                    // –ü–ª–∞–≤–Ω–æ–µ —Å–∫—Ä—ã—Ç–∏–µ —ç–∫—Ä–∞–Ω–∞ –ø—Ä–æ–≤–µ—Ä–∫–∏ –∫–æ–¥–∞
                    document.getElementById('code-check').style.opacity = '0';
                    setTimeout(function() {
                        document.getElementById('code-check').style.display = 'none';
                        // –ü–æ–∫–∞–∑ —ç–∫—Ä–∞–Ω–∞ –≤—ã–±–æ—Ä–∞ —É—Å—Ç—Ä–æ–π—Å—Ç–≤–∞
                        document.getElementById('device-selection').style.display = 'flex';
                    }, 700);
                } else {
                    // –ü–æ–∫–∞–∑ —Å–æ–æ–±—â–µ–Ω–∏—è –æ–± –æ—à–∏–±–∫–µ
                    errorMessage.textContent = '–ù–µ–≤–µ—Ä–Ω—ã–π –∫–æ–¥ –¥–æ—Å—Ç—É–ø–∞. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –ø–æ–ø—Ä–æ–±—É–π—Ç–µ —Å–Ω–æ–≤–∞.';
                    errorMessage.style.opacity = '1';
                    
                    // –û—á–∏—Å—Ç–∫–∞ –ø–æ–ª–µ–π –≤–≤–æ–¥–∞
                    codeInputs.forEach(input => {
                        input.value = '';
                    });
                    codeInputs[0].focus();
                    
                    // –ê–Ω–∏–º–∞—Ü–∏—è —Ç—Ä—è—Å–∫–∏ —Ñ–æ—Ä–º—ã
                    form.classList.add('shake');
                    setTimeout(function() {
                        form.classList.remove('shake');
                    }, 600);
                }
            }
            
            // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –±—ã–ª –ª–∏ —Ä–∞–Ω–µ–µ –≤–≤–µ–¥–µ–Ω –ø—Ä–∞–≤–∏–ª—å–Ω—ã–π –∫–æ–¥
            if (localStorage.getItem('gameAccess') === 'true') {
                document.getElementById('loader').style.opacity = '0';
                setTimeout(function() {
                    document.getElementById('loader').style.display = 'none';
                    document.getElementById('code-check').style.display = 'none';
                    document.getElementById('device-selection').style.display = 'flex';
                }, 1000);
            }
        });

        // –û—Å–Ω–æ–≤–Ω—ã–µ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ
        let scene, camera, renderer, player, controls;
        let enemies = [];
        let bullets = [];
        let enemyBullets = [];
        let walls = [];
        let floor;
        let raycaster;
        let moveForward = false;
        let moveBackward = false;
        let moveLeft = false;
        let moveRight = false;
        let canJump = false;
        let isShooting = false;
        let isCrouching = false;
        let isRunning = false;
        let health = 100;
        let score = 0;
        let level = 1;
        let ammo = 30;
        let maxAmmo = 30;
        let reloading = false;
        let gameOver = false;
        let levelCompleted = false;
        let isMobile = false;
        let joystickPosition = { x: 0, y: 0 };
        let touchLookPosition = { x: 0, y: 0 };
        let lastTouchLookPosition = { x: 0, y: 0 };
        let touchShootId = null;
        let clock = new THREE.Clock();
        let deltaTime = 0;
        let targetEnemy = null;
        let enemyHelpers = [];
        let skybox;
        let textures = {};
        let sounds = {};
        let particleSystems = [];
        let platforms = [];
        let collectibles = [];
        let hasCollectibleKey = false;
        let secretDoors = [];
        let currentCheckpoint = null;
        
        // –ö–æ–Ω—Å—Ç–∞–Ω—Ç—ã
        const ENEMY_COUNT_BASE = 5;
        const LEVEL_SIZE_BASE = 100;
        const ENEMY_SPEED_BASE = 0.05;
        const PLAYER_SPEED = 0.15;
        const RUNNING_SPEED = 0.25;
        const GRAVITY = 0.005;
        const JUMP_FORCE = 0.2;
        const AUTO_AIM_DISTANCE = 20;
        const AUTO_AIM_ANGLE = 0.3;
        
        // –í—ã–±–æ—Ä —É—Å—Ç—Ä–æ–π—Å—Ç–≤–∞
        document.getElementById('pc-button').addEventListener('click', function() {
            isMobile = false;
            document.getElementById('device-selection').style.display = 'none';
            init();
        });
        
        document.getElementById('mobile-button').addEventListener('click', function() {
            isMobile = true;
            document.getElementById('device-selection').style.display = 'none';
            document.getElementById('mobile-controls').style.display = 'block';
            init();
        });
        
        // –ü—Ä–µ–¥–∑–∞–≥—Ä—É–∑–∫–∞ —Ç–µ–∫—Å—Ç—É—Ä
        function preloadTextures() {
            const textureLoader = new THREE.TextureLoader();
            
            // –ó–∞–≥—Ä—É–∑–∫–∞ —Ç–µ–∫—Å—Ç—É—Ä
            textures.ground = textureLoader.load('https://threejs.org/examples/textures/floors/FloorsCheckerboard_S_Diffuse.jpg', function(texture) {
                texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
                texture.repeat.set(10, 10);
            });
            
            textures.wall = textureLoader.load('https://threejs.org/examples/textures/brick_diffuse.jpg', function(texture) {
                texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
                texture.repeat.set(2, 2);
            });
            
            textures.metal = textureLoader.load('https://threejs.org/examples/textures/metal.jpg', function(texture) {
                texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
                texture.repeat.set(1, 1);
            });
            
            textures.wood = textureLoader.load('https://threejs.org/examples/textures/wood.jpg', function(texture) {
                texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
                texture.repeat.set(1, 1);
            });
            
            textures.enemy = textureLoader.load('https://threejs.org/examples/textures/uv_grid_opengl.jpg');
            
                        // –ó–∞–≥—Ä—É–∑–∫–∞ –∫—É–±–∏—á–µ—Å–∫–æ–π —Ç–µ–∫—Å—Ç—É—Ä—ã –¥–ª—è skybox
            const cubeTextureLoader = new THREE.CubeTextureLoader();
            textures.skybox = cubeTextureLoader.load([
                'https://threejs.org/examples/textures/cube/skybox/px.jpg',
                'https://threejs.org/examples/textures/cube/skybox/nx.jpg',
                'https://threejs.org/examples/textures/cube/skybox/py.jpg',
                'https://threejs.org/examples/textures/cube/skybox/ny.jpg',
                'https://threejs.org/examples/textures/cube/skybox/pz.jpg',
                'https://threejs.org/examples/textures/cube/skybox/nz.jpg'
            ]);
        }
        
        // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –∏–≥—Ä—ã
        function init() {
            // –ü—Ä–µ–¥–∑–∞–≥—Ä—É–∑–∫–∞ —Ç–µ–∫—Å—Ç—É—Ä
            preloadTextures();
            
            // –°–æ–∑–¥–∞–Ω–∏–µ —Å—Ü–µ–Ω—ã
            scene = new THREE.Scene();
            scene.background = textures.skybox || new THREE.Color(0x87CEEB);
            scene.fog = new THREE.Fog(0x87CEEB, 0, 500);
            
            // –°–æ–∑–¥–∞–Ω–∏–µ –∫–∞–º–µ—Ä—ã
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.y = 2;
            
            // –°–æ–∑–¥–∞–Ω–∏–µ —Ä–µ–Ω–¥–µ—Ä–µ—Ä–∞ —Å –∞–Ω—Ç–∏–∞–ª–∏–∞—Å–∏–Ω–≥–æ–º –¥–ª—è –ª—É—á—à–µ–π –≥—Ä–∞—Ñ–∏–∫–∏
            renderer = new THREE.WebGLRenderer({ 
                antialias: true,
                powerPreference: "high-performance" 
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio > 2 ? 2 : window.devicePixelRatio); // –û–≥—Ä–∞–Ω–∏—á–µ–Ω–∏–µ –¥–ª—è –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏–∏
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap; // –ú—è–≥–∫–∏–µ —Ç–µ–Ω–∏
            document.body.appendChild(renderer.domElement);
            
            // –î–æ–±–∞–≤–ª–µ–Ω–∏–µ –æ—Å–≤–µ—â–µ–Ω–∏—è
            const ambientLight = new THREE.AmbientLight(0x404040, 0.5);
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(100, 100, 100);
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            directionalLight.shadow.camera.near = 0.5;
            directionalLight.shadow.camera.far = 500;
            directionalLight.shadow.camera.left = -100;
            directionalLight.shadow.camera.right = 100;
            directionalLight.shadow.camera.top = 100;
            directionalLight.shadow.camera.bottom = -100;
            scene.add(directionalLight);
            
            // –î–æ–±–∞–≤–ª–µ–Ω–∏–µ —Ç–æ—á–µ—á–Ω—ã—Ö –∏—Å—Ç–æ—á–Ω–∏–∫–æ–≤ —Å–≤–µ—Ç–∞ –¥–ª—è –±–æ–ª–µ–µ —Ä–µ–∞–ª–∏—Å—Ç–∏—á–Ω–æ–≥–æ –æ—Å–≤–µ—â–µ–Ω–∏—è
            const pointLight1 = new THREE.PointLight(0xffaa00, 1, 50);
            pointLight1.position.set(10, 15, 10);
            pointLight1.castShadow = true;
            scene.add(pointLight1);
            
            const pointLight2 = new THREE.PointLight(0x0044ff, 1, 50);
            pointLight2.position.set(-10, 15, -10);
            pointLight2.castShadow = true;
            scene.add(pointLight2);
            
            // –°–æ–∑–¥–∞–Ω–∏–µ –∏–≥—Ä–æ–∫–∞ (–∫–∞–º–µ—Ä–∞ + —É–ø—Ä–∞–≤–ª–µ–Ω–∏–µ)
            player = new THREE.Object3D();
            player.position.set(0, 2, 0);
            player.add(camera);
            scene.add(player);
            
            // –§–∏–∑–∏–∫–∞ –∏–≥—Ä–æ–∫–∞
            player.velocity = new THREE.Vector3();
            player.direction = new THREE.Vector3();
            
            // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è —Ä–µ–π–∫–∞—Å—Ç–µ—Ä–∞ –¥–ª—è –æ–±–Ω–∞—Ä—É–∂–µ–Ω–∏—è –∫–æ–ª–ª–∏–∑–∏–π
            raycaster = new THREE.Raycaster();
            
            // –°–æ–∑–¥–∞–Ω–∏–µ —É—Ä–æ–≤–Ω—è
            createLevel();
            
            // –ù–∞—Å—Ç—Ä–æ–π–∫–∞ —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è –≤ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –æ—Ç —É—Å—Ç—Ä–æ–π—Å—Ç–≤–∞
            if (isMobile) {
                setupMobileControls();
            } else {
                setupPCControls();
            }
            
            // –û–±—Ä–∞–±–æ—Ç–∫–∞ –∏–∑–º–µ–Ω–µ–Ω–∏—è —Ä–∞–∑–º–µ—Ä–∞ –æ–∫–Ω–∞
            window.addEventListener('resize', onWindowResize, false);
            
            // –ó–∞–ø—É—Å–∫ –∏–≥—Ä–æ–≤–æ–≥–æ —Ü–∏–∫–ª–∞
            animate();
        }
        
        // –ù–∞—Å—Ç—Ä–æ–π–∫–∞ —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è –¥–ª—è –ü–ö
        function setupPCControls() {
            document.addEventListener('keydown', onKeyDown, false);
            document.addEventListener('keyup', onKeyUp, false);
            document.addEventListener('mousedown', onMouseDown, false);
            document.addEventListener('mouseup', onMouseUp, false);
            
            // –ë–ª–æ–∫–∏—Ä–æ–≤–∫–∞ —É–∫–∞–∑–∞—Ç–µ–ª—è –º—ã—à–∏
            renderer.domElement.addEventListener('click', function() {
                renderer.domElement.requestPointerLock();
            });
            
            document.addEventListener('pointerlockchange', lockChangeAlert, false);
        }
        
        // –ù–∞—Å—Ç—Ä–æ–π–∫–∞ —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è –¥–ª—è –º–æ–±–∏–ª—å–Ω—ã—Ö —É—Å—Ç—Ä–æ–π—Å—Ç–≤
        function setupMobileControls() {
            // –ù–∞—Å—Ç—Ä–æ–π–∫–∞ –¥–∂–æ–π—Å—Ç–∏–∫–∞ –¥–ª—è –¥–≤–∏–∂–µ–Ω–∏—è
            const joystickArea = document.querySelector('.joystick-area');
            const joystick = document.getElementById('joystick');
            
            joystickArea.addEventListener('touchstart', function(e) {
                e.preventDefault();
                const touch = e.touches[0];
                const rect = joystickArea.getBoundingClientRect();
                const centerX = rect.left + rect.width / 2;
                const centerY = rect.top + rect.height / 2;
                
                updateJoystickPosition(touch.clientX - centerX, touch.clientY - centerY);
            });
            
            joystickArea.addEventListener('touchmove', function(e) {
                e.preventDefault();
                const touch = e.touches[0];
                const rect = joystickArea.getBoundingClientRect();
                const centerX = rect.left + rect.width / 2;
                const centerY = rect.top + rect.height / 2;
                
                updateJoystickPosition(touch.clientX - centerX, touch.clientY - centerY);
            });
            
            joystickArea.addEventListener('touchend', function(e) {
                e.preventDefault();
                resetJoystick();
            });
            
            // –ù–∞—Å—Ç—Ä–æ–π–∫–∞ –æ–±–ª–∞—Å—Ç–∏ –¥–ª—è –æ–±–∑–æ—Ä–∞
            const lookArea = document.getElementById('look-area');
            
            lookArea.addEventListener('touchstart', function(e) {
                e.preventDefault();
                const touch = e.touches[0];
                lastTouchLookPosition.x = touch.clientX;
                lastTouchLookPosition.y = touch.clientY;
                touchLookPosition.x = touch.clientX;
                touchLookPosition.y = touch.clientY;
            });
            
            lookArea.addEventListener('touchmove', function(e) {
                e.preventDefault();
                const touch = e.touches[0];
                touchLookPosition.x = touch.clientX;
                touchLookPosition.y = touch.clientY;
            });
            
            // –ù–∞—Å—Ç—Ä–æ–π–∫–∞ –∫–Ω–æ–ø–æ–∫ –¥–µ–π—Å—Ç–≤–∏–π
            document.getElementById('shoot-button').addEventListener('touchstart', function(e) {
                e.preventDefault();
                isShooting = true;
                shoot();
                touchShootId = setInterval(shoot, 200);
            });
            
            document.getElementById('shoot-button').addEventListener('touchend', function(e) {
                e.preventDefault();
                isShooting = false;
                if (touchShootId !== null) {
                    clearInterval(touchShootId);
                    touchShootId = null;
                }
            });
            
            document.getElementById('jump-button').addEventListener('touchstart', function(e) {
                e.preventDefault();
                if (canJump) {
                    player.velocity.y = JUMP_FORCE;
                    canJump = false;
                }
            });
            
            document.getElementById('reload-button').addEventListener('touchstart', function(e) {
                e.preventDefault();
                reload();
            });
            
            function updateJoystickPosition(x, y) {
                const maxDistance = 40;
                const distance = Math.sqrt(x * x + y * y);
                
                if (distance > maxDistance) {
                    const ratio = maxDistance / distance;
                    x *= ratio;
                    y *= ratio;
                }
                
                joystick.style.transform = `translate(${x}px, ${y}px)`;
                
                // –ù–æ—Ä–º–∞–ª–∏–∑–∞—Ü–∏—è –∑–Ω–∞—á–µ–Ω–∏–π –¥–ª—è –¥–≤–∏–∂–µ–Ω–∏—è - –ò–°–ü–†–ê–í–õ–ï–ù–û –¥–≤–∏–∂–µ–Ω–∏–µ –¥–ª—è –º–æ–±–∏–ª—å–Ω—ã—Ö
                joystickPosition.x = x / maxDistance;
                joystickPosition.y = y / maxDistance;
                
                // –£—Å—Ç–∞–Ω–æ–≤–∫–∞ —Ñ–ª–∞–≥–æ–≤ –¥–≤–∏–∂–µ–Ω–∏—è - –ò–°–ü–†–ê–í–õ–ï–ù–û –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–µ
                moveForward = joystickPosition.y < -0.2;  // –í–ø–µ—Ä–µ–¥ –ø—Ä–∏ –ø–µ—Ä–µ–º–µ—â–µ–Ω–∏–∏ –¥–∂–æ–π—Å—Ç–∏–∫–∞ –≤–≤–µ—Ä—Ö
                moveBackward = joystickPosition.y > 0.2;  // –ù–∞–∑–∞–¥ –ø—Ä–∏ –ø–µ—Ä–µ–º–µ—â–µ–Ω–∏–∏ –¥–∂–æ–π—Å—Ç–∏–∫–∞ –≤–Ω–∏–∑
                moveLeft = joystickPosition.x < -0.2;     // –í–ª–µ–≤–æ –ø—Ä–∏ –ø–µ—Ä–µ–º–µ—â–µ–Ω–∏–∏ –¥–∂–æ–π—Å—Ç–∏–∫–∞ –≤–ª–µ–≤–æ
                moveRight = joystickPosition.x > 0.2;     // –í–ø—Ä–∞–≤–æ –ø—Ä–∏ –ø–µ—Ä–µ–º–µ—â–µ–Ω–∏–∏ –¥–∂–æ–π—Å—Ç–∏–∫–∞ –≤–ø—Ä–∞–≤–æ
            }
            
            function resetJoystick() {
                joystick.style.transform = 'translate(0, 0)';
                joystickPosition.x = 0;
                joystickPosition.y = 0;
                moveForward = false;
                moveBackward = false;
                moveLeft = false;
                moveRight = false;
            }
        }
        
        // –°–æ–∑–¥–∞–Ω–∏–µ —É—Ä–æ–≤–Ω—è
        function createLevel() {
            // –û—á–∏—Å—Ç–∫–∞ –ø—Ä–µ–¥—ã–¥—É—â–µ–≥–æ —É—Ä–æ–≤–Ω—è
            while(scene.children.length > 0){ 
                scene.remove(scene.children[0]); 
            }
            
            enemies = [];
            bullets = [];
            enemyBullets = [];
            walls = [];
            enemyHelpers = [];
            particleSystems = [];
            platforms = [];
            collectibles = [];
            secretDoors = [];
            hasCollectibleKey = false;
            
            // –î–æ–±–∞–≤–ª–µ–Ω–∏–µ –∏–≥—Ä–æ–∫–∞ –∏ –æ—Å–≤–µ—â–µ–Ω–∏—è –æ–±—Ä–∞—Ç–Ω–æ –Ω–∞ —Å—Ü–µ–Ω—É
            scene.add(player);
            
            const ambientLight = new THREE.AmbientLight(0x404040, 0.5);
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(100, 100, 100);
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            scene.add(directionalLight);
            
            // –î–æ–±–∞–≤–ª–µ–Ω–∏–µ —Ç–æ—á–µ—á–Ω—ã—Ö –∏—Å—Ç–æ—á–Ω–∏–∫–æ–≤ —Å–≤–µ—Ç–∞
            const pointLight1 = new THREE.PointLight(0xffaa00, 1, 50);
            pointLight1.position.set(10, 15, 10);
            pointLight1.castShadow = true;
            scene.add(pointLight1);
            
            const pointLight2 = new THREE.PointLight(0x0044ff, 1, 50);
            pointLight2.position.set(-10, 15, -10);
            pointLight2.castShadow = true;
            scene.add(pointLight2);
            
            // –°–æ–∑–¥–∞–Ω–∏–µ skybox
            if (textures.skybox) {
                scene.background = textures.skybox;
            }
            
            // –†–∞–∑–º–µ—Ä —É—Ä–æ–≤–Ω—è —Ä–∞—Å—Ç–µ—Ç —Å –∫–∞–∂–¥—ã–º —É—Ä–æ–≤–Ω–µ–º
            const levelSize = LEVEL_SIZE_BASE + (level * 20);
            
            // –°–æ–∑–¥–∞–Ω–∏–µ –ø–æ–ª–∞ —Å —Ç–µ–∫—Å—Ç—É—Ä–æ–π
            const floorGeometry = new THREE.PlaneGeometry(levelSize, levelSize, 10, 10);
            const floorMaterial = new THREE.MeshStandardMaterial({ 
                map: textures.ground,
                roughness: 0.8,
                metalness: 0.2
            });
            floor = new THREE.Mesh(floorGeometry, floorMaterial);
            floor.rotation.x = -Math.PI / 2;
            floor.receiveShadow = true;
            scene.add(floor);
            
            // –°–æ–∑–¥–∞–Ω–∏–µ —Å—Ç–µ–Ω
            createWalls(levelSize);
            
            // –°–æ–∑–¥–∞–Ω–∏–µ –ø–∞—Ä–∫—É—Ä-—ç–ª–µ–º–µ–Ω—Ç–æ–≤ –∏ –ø—Ä–µ–ø—è—Ç—Å—Ç–≤–∏–π –≤ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –æ—Ç —É—Ä–æ–≤–Ω—è
            if (level === 1) {
                createTutorialLevel(levelSize);
            } else if (level === 2) {
                createParkourLevel(levelSize);
            } else if (level === 3) {
                createMazeLevel(levelSize);
            } else {
                createAdvancedLevel(levelSize);
            }
            
            // –°–æ–∑–¥–∞–Ω–∏–µ –≤—Ä–∞–≥–æ–≤
            const enemyCount = ENEMY_COUNT_BASE + (level * 2);
            createEnemies(enemyCount, levelSize);
            
            // –°–±—Ä–æ—Å –ø–æ–∑–∏—Ü–∏–∏ –∏–≥—Ä–æ–∫–∞ –∏ —É—Å—Ç–∞–Ω–æ–≤–∫–∞ –Ω–∞ —Å—Ç–∞—Ä—Ç–æ–≤—É—é —Ç–æ—á–∫—É
            player.position.set(0, 2, 0);
            player.velocity.set(0, 0, 0);
            
            // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ HUD
            document.getElementById('level').textContent = level;
            document.getElementById('score').textContent = score;
            updateHealthBar();
            
            // –°–±—Ä–æ—Å –ø–∞—Ç—Ä–æ–Ω–æ–≤
            ammo = maxAmmo;
            document.getElementById('ammo-count').textContent = ammo;
            document.getElementById('max-ammo').textContent = maxAmmo;
        }
        
        // –°–æ–∑–¥–∞–Ω–∏–µ —Å—Ç–µ–Ω –≤–æ–∫—Ä—É–≥ —É—Ä–æ–≤–Ω—è
        function createWalls(size) {
            const wallHeight = 10;
            const wallThickness = 2;
            const halfSize = size / 2;
            
            const wallMaterial = new THREE.MeshStandardMaterial({ 
                map: textures.wall,
                roughness: 0.7,
                metalness: 0.2,
                bumpMap: textures.wall,
                bumpScale: 0.02
            });
            
            // –°–µ–≤–µ—Ä–Ω–∞—è —Å—Ç–µ–Ω–∞
            const northWallGeometry = new THREE.BoxGeometry(size + wallThickness * 2, wallHeight, wallThickness);
            const northWall = new THREE.Mesh(northWallGeometry, wallMaterial);
            northWall.position.set(0, wallHeight / 2, -halfSize - wallThickness / 2);
            northWall.castShadow = true;
            northWall.receiveShadow = true;
            scene.add(northWall);
            walls.push(northWall);
            
            // –Æ–∂–Ω–∞—è —Å—Ç–µ–Ω–∞
            const southWall = northWall.clone();
            southWall.position.z = halfSize + wallThickness / 2;
            scene.add(southWall);
            walls.push(southWall);
            
            // –í–æ—Å—Ç–æ—á–Ω–∞—è —Å—Ç–µ–Ω–∞
            const eastWallGeometry = new THREE.BoxGeometry(wallThickness, wallHeight, size);
            const eastWall = new THREE.Mesh(eastWallGeometry, wallMaterial);
            eastWall.position.set(halfSize + wallThickness / 2, wallHeight / 2, 0);
            eastWall.castShadow = true;
            eastWall.receiveShadow = true;
            scene.add(eastWall);
            walls.push(eastWall);
            
            // –ó–∞–ø–∞–¥–Ω–∞—è —Å—Ç–µ–Ω–∞
            const westWall = eastWall.clone();
            westWall.position.x = -halfSize - wallThickness / 2;
            scene.add(westWall);
            walls.push(westWall);
        }
        
        // –°–æ–∑–¥–∞–Ω–∏–µ –æ–±—É—á–∞—é—â–µ–≥–æ —É—Ä–æ–≤–Ω—è
        function createTutorialLevel(size) {
            const halfSize = size / 2 - 5;
            
            // –°–æ–∑–¥–∞–Ω–∏–µ –ø–ª–∞—Ç—Ñ–æ—Ä–º –¥–ª—è –æ–±—É—á–µ–Ω–∏—è –ø—Ä—ã–∂–∫–∞–º
            createPlatform(10, 1, 10, 0, 0, -15, 0x4d4dff);
            createPlatform(8, 1, 8, 0, 2, -25, 0x4d7fff);
            createPlatform(6, 1, 6, 0, 4, -35, 0x4db8ff);
            
            // –°–æ–∑–¥–∞–Ω–∏–µ –Ω–µ—Å–∫–æ–ª—å–∫–∏—Ö –ø—Ä–µ–ø—è—Ç—Å—Ç–≤–∏–π
            createObstacle(5, 3, 2, -10, 1.5, 10, 0x8c8c8c);
            createObstacle(5, 3, 2, 10, 1.5, 10, 0x8c8c8c);
            
            // –°–æ–∑–¥–∞–Ω–∏–µ –∫–ª—é—á–∞-–∫–æ–ª–ª–µ–∫—Ç–∏–±–ª–∞
            createCollectible(0, 1, -40, 'key');
            
            // –°–æ–∑–¥–∞–Ω–∏–µ —Å–µ–∫—Ä–µ—Ç–Ω–æ–π –¥–≤–µ—Ä–∏, –∫–æ—Ç–æ—Ä–∞—è –æ—Ç–∫—Ä—ã–≤–∞–µ—Ç—Å—è –∫–ª—é—á–æ–º
            createSecretDoor(15, 5, 2, 20, 2.5, 0, 0x7d4d4d);
            
            // –°–æ–∑–¥–∞–Ω–∏–µ –∫–æ–Ω—Ç—Ä–æ–ª—å–Ω–æ–π —Ç–æ—á–∫–∏
            createCheckpoint(0, 0, -15);
        }
        
        // –°–æ–∑–¥–∞–Ω–∏–µ —É—Ä–æ–≤–Ω—è —Å –ø–∞—Ä–∫—É—Ä–æ–º
        function createParkourLevel(size) {
            const halfSize = size / 2 - 5;
            
            // –°–æ–∑–¥–∞–Ω–∏–µ —Å–µ—Ä–∏–∏ –ø–ª–∞—Ç—Ñ–æ—Ä–º –¥–ª—è –ø–∞—Ä–∫—É—Ä–∞
            const platformPositions = [
                { x: 5, y: 1, z: -10 },
                { x: 10, y: 3, z: -15 },
                { x: 15, y: 5, z: -20 },
                { x: 10, y: 7, z: -25 },
                { x: 5, y: 9, z: -30 },
                { x: 0, y: 11, z: -35 },
                { x: -5, y: 9, z: -30 },
                { x: -10, y: 7, z: -25 },
                { x: -15, y: 5, z: -20 },
                { x: -10, y: 3, z: -15 },
                { x: -5, y: 1, z: -10 }
            ];
            
            platformPositions.forEach((pos, index) => {
                createPlatform(4, 1, 4, pos.x, pos.y, pos.z, 0x4d4dff + index * 0x000011);
            });
            
            // –°–æ–∑–¥–∞–Ω–∏–µ –¥–≤–∏–∂—É—â–∏—Ö—Å—è –ø–ª–∞—Ç—Ñ–æ—Ä–º
            createMovingPlatform(4, 1, 4, 0, 5, 0, 20, 0, 0, 0x4dffbd);
            createMovingPlatform(4, 1, 4, 20, 8, -20, 0, 0, 20, 0x4dffda);
            
            // –°–æ–∑–¥–∞–Ω–∏–µ —Å–ª–æ–∂–Ω—ã—Ö –ø—Ä–µ–ø—è—Ç—Å—Ç–≤–∏–π
            createObstacle(2, 10, 2, -20, 5, 10, 0x8c8c8c);
            createObstacle(2, 10, 2, -20, 5, 15, 0x8c8c8c);
            createObstacle(2, 10, 2, -20, 5, 20, 0x8c8c8c);
            
            // –°–æ–∑–¥–∞–Ω–∏–µ –∫–æ–ª–ª–µ–∫—Ç–∏–±–ª–æ–≤
            createCollectible(-10, 8, -25, 'ammo');
            createCollectible(10, 8, -25, 'health');
            createCollectible(0, 12, -35, 'key');
            
            // –°–æ–∑–¥–∞–Ω–∏–µ —Å–µ–∫—Ä–µ—Ç–Ω–æ–π –¥–≤–µ—Ä–∏
            createSecretDoor(10, 5, 2, 30, 2.5, 30, 0x7d4d4d);
            
            // –°–æ–∑–¥–∞–Ω–∏–µ –∫–æ–Ω—Ç—Ä–æ–ª—å–Ω—ã—Ö —Ç–æ—á–µ–∫
            createCheckpoint(5, 1, -10);
            createCheckpoint(0, 11, -35);
        }
        
        // –°–æ–∑–¥–∞–Ω–∏–µ —É—Ä–æ–≤–Ω—è —Å –ª–∞–±–∏—Ä–∏–Ω—Ç–æ–º
        function createMazeLevel(size) {
            const halfSize = size / 2 - 10;
            const wallHeight = 4;
            const wallThickness = 2;
            const corridorWidth = 6;
            
            // –°–æ–∑–¥–∞–Ω–∏–µ —Å—Ç–µ–Ω–æ–∫ –ª–∞–±–∏—Ä–∏–Ω—Ç–∞
            const mazeMaterial = new THREE.MeshStandardMaterial({ 
                map: textures.wall,
                roughness: 0.8,
                metalness: 0.2
            });
            
            // –ì–æ—Ä–∏–∑–æ–Ω—Ç–∞–ª—å–Ω—ã–µ —Å—Ç–µ–Ω–∫–∏
            const horizontalWalls = [
                { x: 0, z: -20, length: 40 },
                { x: -20, z: 0, length: 40 },
                { x: 20, z: 0, length: 40 },
                { x: -10, z: 10, length: 20 },
                { x: 10, z: -10, length: 20 },
                { x: -30, z: -30, length: 20 },
                { x: 30, z: 30, length: 20 }
            ];
            
            horizontalWalls.forEach(wall => {
                const wallGeometry = new THREE.BoxGeometry(wall.length, wallHeight, wallThickness);
                const wallMesh = new THREE.Mesh(wallGeometry, mazeMaterial);
                wallMesh.position.set(wall.x, wallHeight / 2, wall.z);
                wallMesh.castShadow = true;
                wallMesh.receiveShadow = true;
                scene.add(wallMesh);
                walls.push(wallMesh);
            });
            
            // –í–µ—Ä—Ç–∏–∫–∞–ª—å–Ω—ã–µ —Å—Ç–µ–Ω–∫–∏
            const verticalWalls = [
                { x: -20, z: 0, length: 40 },
                { x: 20, z: 0, length: 40 },
                { x: 0, z: 20, length: 40 },
                { x: -10, z: -10, length: 20 },
                { x: 10, z: 10, length: 20 },
                { x: -30, z: 30, length: 20 },
                { x: 30, z: -30, length: 20 }
            ];
            
            verticalWalls.forEach(wall => {
                const wallGeometry = new THREE.BoxGeometry(wallThickness, wallHeight, wall.length);
                const wallMesh = new THREE.Mesh(wallGeometry, mazeMaterial);
                wallMesh.position.set(wall.x, wallHeight / 2, wall.z);
                wallMesh.castShadow = true;
                wallMesh.receiveShadow = true;
                scene.add(wallMesh);
                walls.push(wallMesh);
            });
            
            // –°–æ–∑–¥–∞–Ω–∏–µ –ø–ª–∞—Ç—Ñ–æ—Ä–º –∏ –ø—Ä–µ–ø—è—Ç—Å—Ç–≤–∏–π –≤ –ª–∞–±–∏—Ä–∏–Ω—Ç–µ
            createPlatform(5, 1, 5, -25, 3, -25, 0x4d4dff);
            createPlatform(5, 1, 5, 25, 3, 25, 0x4d4dff);
            
            // –°–æ–∑–¥–∞–Ω–∏–µ –∫–æ–ª–ª–µ–∫—Ç–∏–±–ª–æ–≤
            createCollectible(-25, 4, -25, 'key');
            createCollectible(25, 4, 25, 'ammo');
            createCollectible(-15, 1, 15, 'health');
            
            // –°–æ–∑–¥–∞–Ω–∏–µ —Å–µ–∫—Ä–µ—Ç–Ω–æ–π –¥–≤–µ—Ä–∏
            createSecretDoor(10, 5, 2, 0, 2.5, 30, 0x7d4d4d);
            
            // –°–æ–∑–¥–∞–Ω–∏–µ –∫–æ–Ω—Ç—Ä–æ–ª—å–Ω—ã—Ö —Ç–æ—á–µ–∫
            createCheckpoint(0, 0, 0);
            createCheckpoint(-25, 4, -25);
        }
        
        // –°–æ–∑–¥–∞–Ω–∏–µ –ø—Ä–æ–¥–≤–∏–Ω—É—Ç–æ–≥–æ —É—Ä–æ–≤–Ω—è
        function createAdvancedLevel(size) {
            const halfSize = size / 2 - 10;
            
            // –°–æ–∑–¥–∞–Ω–∏–µ –º–Ω–æ–≥–æ—É—Ä–æ–≤–Ω–µ–≤—ã—Ö –ø–ª–∞—Ç—Ñ–æ—Ä–º
            for (let i = 0; i < 5; i++) {
                createPlatform(10 - i, 1, 10 - i, 0, i * 3, -20 - i * 5, 0x4d4dff + i * 0x001100);
            }
            
            // –°–æ–∑–¥–∞–Ω–∏–µ –¥–≤–∏–∂—É—â–∏—Ö—Å—è –ø–ª–∞—Ç—Ñ–æ—Ä–º
            createMovingPlatform(5, 1, 5, 20, 5, 0, 20, 0, 20, 0x4dffbd);
            createMovingPlatform(5, 1, 5, -20, 10, -20, 20, 0, 0, 0x4dffda);
            createMovingPlatform(5, 1, 5, 0, 15, 20, 0, 5, 0, 0x4deeff);
            
            // –°–æ–∑–¥–∞–Ω–∏–µ —Å–ª–æ–∂–Ω—ã—Ö –ø—Ä–µ–ø—è—Ç—Å—Ç–≤–∏–π –∏ –±–∞—Ä—å–µ—Ä–æ–≤
            createObstacle(2, 10, 30, -30, 5, 0, 0x8c8c8c);
            createObstacle(30, 10, 2, 0, 5, 30, 0x8c8c8c);
            
            // –°–æ–∑–¥–∞–Ω–∏–µ –≤—Ä–∞—â–∞—é—â–∏—Ö—Å—è –ø—Ä–µ–ø—è—Ç—Å—Ç–≤–∏–π
            createRotatingObstacle(2, 10, 2, 0, 5, 0, 0x8c8c8c);
            createRotatingObstacle(20, 1, 1, 0, 10, 0, 0xff4d4d);
            
            // –°–æ–∑–¥–∞–Ω–∏–µ –∫–æ–ª–ª–µ–∫—Ç–∏–±–ª–æ–≤
            createCollectible(0, 15, -40, 'key');
            createCollectible(20, 6, 0, 'ammo');
            createCollectible(-20, 11, -20, 'health');
            
            // –°–æ–∑–¥–∞–Ω–∏–µ —Å–µ–∫—Ä–µ—Ç–Ω—ã—Ö –¥–≤–µ—Ä–µ–π
            createSecretDoor(10, 5, 2, halfSize - 5, 2.5, 0, 0x7d4d4d);
            
            // –°–æ–∑–¥–∞–Ω–∏–µ –¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã—Ö –∫–æ–Ω—Ç—Ä–æ–ª—å–Ω—ã—Ö —Ç–æ—á–µ–∫
            createCheckpoint(0, 0, 0);
            createCheckpoint(0, 15, -40);
            createCheckpoint(0, 13, 20);
        }
        
        // –§—É–Ω–∫—Ü–∏—è —Å–æ–∑–¥–∞–Ω–∏—è –ø–ª–∞—Ç—Ñ–æ—Ä–º—ã
        function createPlatform(width, height, depth, x, y, z, color) {
            const platformGeometry = new THREE.BoxGeometry(width, height, depth);
            const platformMaterial = new THREE.MeshStandardMaterial({ 
                color: color || 0x4d4dff,
                map: textures.metal,
                roughness: 0.4,
                metalness: 0.6
            });
            const platform = new THREE.Mesh(platformGeometry, platformMaterial);
            platform.position.set(x, y, z);
            platform.castShadow = true;
            platform.receiveShadow = true;
            scene.add(platform);
            walls.push(platform);
            platforms.push(platform);
            return platform;
        }
        
        // –§—É–Ω–∫—Ü–∏—è —Å–æ–∑–¥–∞–Ω–∏—è –¥–≤–∏–∂—É—â–µ–π—Å—è –ø–ª–∞—Ç—Ñ–æ—Ä–º—ã
        function createMovingPlatform(width, height, depth, x, y, z, rangeX, rangeY, rangeZ, color) {
            const platform = createPlatform(width, height, depth, x, y, z, color);
            platform.isMoving = true;
            platform.startPosition = new THREE.Vector3(x, y, z);
            platform.rangeX = rangeX;
            platform.rangeY = rangeY;
            platform.rangeZ = rangeZ;
            platform.movementSpeed = 0.02;
            platform.movementDirection = 1;
            platform.movementProgress = 0;
            return platform;
        }
        
        // –§—É–Ω–∫—Ü–∏—è —Å–æ–∑–¥–∞–Ω–∏—è –≤—Ä–∞—â–∞—é—â–µ–≥–æ—Å—è –ø—Ä–µ–ø—è—Ç—Å—Ç–≤–∏—è
        function createRotatingObstacle(width, height, depth, x, y, z, color) {
            const obstacleGeometry = new THREE.BoxGeometry(width, height, depth);
            const obstacleMaterial = new THREE.MeshStandardMaterial({ 
                color: color || 0x8c8c8c,
                map: textures.metal,
                roughness: 0.6,
                metalness: 0.4
            });
            const obstacle = new THREE.Mesh(obstacleGeometry, obstacleMaterial);
            obstacle.position.set(x, y, z);
            obstacle.castShadow = true;
            obstacle.receiveShadow = true;
            scene.add(obstacle);
            walls.push(obstacle);
            
            obstacle.isRotating = true;
            obstacle.rotationSpeed = 0.02;
            obstacle.rotationAxis = new THREE.Vector3(0, 1, 0);
            
            return obstacle;
        }
        
        // –§—É–Ω–∫—Ü–∏—è —Å–æ–∑–¥–∞–Ω–∏—è –ø—Ä–µ–ø—è—Ç—Å—Ç–≤–∏—è
        function createObstacle(width, height, depth, x, y, z, color) {
            const obstacleGeometry = new THREE.BoxGeometry(width, height, depth);
            const obstacleMaterial = new THREE.MeshStandardMaterial({ 
                color: color || 0x8c8c8c,
                map: textures.wall,
                roughness: 0.8,
                metalness: 0.2
            });
            const obstacle = new THREE.Mesh(obstacleGeometry, obstacleMaterial);
            obstacle.position.set(x, y, z);
            obstacle.castShadow = true;
            obstacle.receiveShadow = true;
            scene.add(obstacle);
            walls.push(obstacle);
            return obstacle;
        }
        
        // –§—É–Ω–∫—Ü–∏—è —Å–æ–∑–¥–∞–Ω–∏—è –∫–æ–ª–ª–µ–∫—Ç–∏–±–ª–∞
        function createCollectible(x, y, z, type) {
            let collectibleGeometry, collectibleMaterial;
            
            switch(type) {
                case 'key':
                    collectibleGeometry = new THREE.TorusGeometry(0.5, 0.2, 16, 32);
                    collectibleMaterial = new THREE.MeshStandardMaterial({ 
                        color: 0xffcc00,
                        metalness: 0.8,
                        roughness: 0.2,
                        emissive: 0xffcc00,
                        emissiveIntensity: 0.5
                    });
                    break;
                case 'health':
                    collectibleGeometry = new THREE.BoxGeometry(0.8, 0.8, 0.8);
                    collectibleMaterial = new THREE.MeshStandardMaterial({ 
                        color: 0x00ff00,
                        metalness: 0.5,
                        roughness: 0.5,
                        emissive: 0x00ff00,
                        emissiveIntensity: 0.5
                    });
                    break;
                case 'ammo':
                    collectibleGeometry = new THREE.CylinderGeometry(0.2, 0.2, 0.8, 8);
                    collectibleMaterial = new THREE.MeshStandardMaterial({ 
                        color: 0xffff00,
                        metalness: 0.7,
                        roughness: 0.3,
                        emissive: 0xffff00,
                        emissiveIntensity: 0.5
                    });
                    break;
                default:
                    collectibleGeometry = new THREE.SphereGeometry(0.5, 16, 16);
                    collectibleMaterial = new THREE.MeshStandardMaterial({ 
                        color: 0x00ffff,
                        metalness: 0.6,
                        roughness: 0.4,
                        emissive: 0x00ffff,
                        emissiveIntensity: 0.5
                    });
            }
            
            const collectible = new THREE.Mesh(collectibleGeometry, collectibleMaterial);
            collectible.position.set(x, y, z);
            collectible.castShadow = true;
            collectible.receiveShadow = true;
            collectible.collectibleType = type;
            collectible.rotation.x = Math.PI / 2;
            
            // –î–æ–±–∞–≤–ª–µ–Ω–∏–µ –∞–Ω–∏–º–∞—Ü–∏–∏ –≤—Ä–∞—â–µ–Ω–∏—è –∏ –ø–æ–¥–ø—Ä—ã–≥–∏–≤–∞–Ω–∏—è
            collectible.isCollectible = true;
            collectible.rotationSpeed = 0.02;
            collectible.floatSpeed = 0.01;
            collectible.floatHeight = 0.5;
            collectible.floatDirection = 1;
            collectible.floatProgress = 0;
            collectible.originalY = y;
            
            scene.add(collectible);
            collectibles.push(collectible);
            return collectible;
        }
        
        // –§—É–Ω–∫—Ü–∏—è —Å–æ–∑–¥–∞–Ω–∏—è —Å–µ–∫—Ä–µ—Ç–Ω–æ–π –¥–≤–µ—Ä–∏
        function createSecretDoor(width, height, depth, x, y, z, color) {
            const doorGeometry = new THREE.BoxGeometry(width, height, depth);
            const doorMaterial = new THREE.MeshStandardMaterial({ 
                color: color || 0x7d4d4d,
                map: textures.wood,
                roughness: 0.7,
                metalness: 0.3
            });
            const door = new THREE.Mesh(doorGeometry, doorMaterial);
            door.position.set(x, y, z);
            door.castShadow = true;
            door.receiveShadow = true;
            door.isSecretDoor = true;
            door.isOpen = false;
            scene.add(door);
            walls.push(door);
            secretDoors.push(door);
            return door;
        }
        
        // –§—É–Ω–∫—Ü–∏—è —Å–æ–∑–¥–∞–Ω–∏—è –∫–æ–Ω—Ç—Ä–æ–ª—å–Ω–æ–π —Ç–æ—á–∫–∏
        function createCheckpoint(x, y, z) {
            const checkpointGeometry = new THREE.CylinderGeometry(1, 1, 0.2, 16);
            const checkpointMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x00ffff,
                transparent: true,
                opacity: 0.5,
                emissive: 0x00ffff,
                emissiveIntensity: 0.5
            });
            const checkpoint = new THREE.Mesh(checkpointGeometry, checkpointMaterial);
            checkpoint.position.set(x, y + 0.1, z);
            checkpoint.rotation.x = Math.PI / 2;
            checkpoint.receiveShadow = true;
            checkpoint.isCheckpoint = true;
            
            // –°–æ–∑–¥–∞–Ω–∏–µ —ç—Ñ—Ñ–µ–∫—Ç–∞ —Å–≤–µ—á–µ–Ω–∏—è
            const glowGeometry = new THREE.CylinderGeometry(1.2, 1.2, 0.1, 16);
            const glowMaterial = new THREE.MeshBasicMaterial({ 
                color: 0x00ffff,
                transparent: true,
                opacity: 0.3,
                side: THREE.DoubleSide
            });
            const glow = new THREE.Mesh(glowGeometry, glowMaterial);
            checkpoint.add(glow);
            
            scene.add(checkpoint);
            return checkpoint;
        }
        
        // –°–æ–∑–¥–∞–Ω–∏–µ —Å–ª—É—á–∞–π–Ω—ã—Ö –ø—Ä–µ–ø—è—Ç—Å—Ç–≤–∏–π –Ω–∞ —É—Ä–æ–≤–Ω–µ
        function createObstacles(size) {
            const obstacleCount = 10 + level * 2;
            const halfSize = size / 2 - 5;
            
            for (let i = 0; i < obstacleCount; i++) {
                // –°–ª—É—á–∞–π–Ω—ã–π —Ä–∞–∑–º–µ—Ä
                const width = Math.random() * 5 + 2;
                const height = Math.random() * 4 + 2;
                const depth = Math.random() * 5 + 2;
                
                // –°–ª—É—á–∞–π–Ω–∞—è –ø–æ–∑–∏—Ü–∏—è
                const x = Math.random() * (halfSize * 2) - halfSize;
                const z = Math.random() * (halfSize * 2) - halfSize;
                
                // –ù–µ —Å–æ–∑–¥–∞–≤–∞—Ç—å –ø—Ä–µ–ø—è—Ç—Å—Ç–≤–∏—è —Å–ª–∏—à–∫–æ–º –±–ª–∏–∑–∫–æ –∫ –∏–≥—Ä–æ–∫—É
                if (Math.abs(x) < 10 && Math.abs(z) < 10) continue;
                
                // –°–ª—É—á–∞–π–Ω—ã–π —Ü–≤–µ—Ç
                const color = new THREE.Color(Math.random() * 0.5, Math.random() * 0.5, Math.random() * 0.5);
                
                // –°–ª—É—á–∞–π–Ω–∞—è –≥–µ–æ–º–µ—Ç—Ä–∏—è –¥–ª—è —Ä–∞–∑–Ω–æ–æ–±—Ä–∞–∑–∏—è
                let obstacleGeometry;
                const geometryType = Math.floor(Math.random() * 3);
                
                switch (geometryType) {
                    case 0:
                        obstacleGeometry = new THREE.BoxGeometry(width, height, depth);
                        break;
                    case 1:
                        obstacleGeometry = new THREE.CylinderGeometry(width/2, width/2, height, 8);
                        break;
                    case 2:
                        obstacleGeometry = new THREE.TorusGeometry(width/2, depth/4, 16, 16);
                        break;
                }
                
                const obstacleMaterial = new THREE.MeshStandardMaterial({ 
                    color: color,
                    roughness: 0.7,
                    metalness: 0.2
                });
                const obstacle = new THREE.Mesh(obstacleGeometry, obstacleMaterial);
                obstacle.position.set(x, height / 2, z);
                obstacle.castShadow = true;
                obstacle.receiveShadow = true;
                
                // –î–æ–±–∞–≤–ª–µ–Ω–∏–µ —Å–ª—É—á–∞–π–Ω–æ–≥–æ –≤—Ä–∞—â–µ–Ω–∏—è –¥–ª—è –Ω–µ–∫–æ—Ç–æ—Ä—ã—Ö –æ–±—ä–µ–∫—Ç–æ–≤
                if (Math.random() > 0.5) {
                    obstacle.rotation.x = Math.random() * Math.PI;
                    obstacle.rotation.y = Math.random() * Math.PI;
                    obstacle.rotation.z = Math.random() * Math.PI;
                }
                
                scene.add(obstacle);
                walls.push(obstacle);
            }
        }
        
        // –°–æ–∑–¥–∞–Ω–∏–µ –≤—Ä–∞–≥–æ–≤
        function createEnemies(count, size) {
            const halfSize = size / 2 - 10;
            
            for (let i = 0; i < count; i++) {
                // –°–ª—É—á–∞–π–Ω–∞—è –ø–æ–∑–∏—Ü–∏—è
                const x = Math.random() * (halfSize * 2) - halfSize;
                const z = Math.random() * (halfSize * 2) - halfSize;
                
                // –ù–µ —Å–æ–∑–¥–∞–≤–∞—Ç—å –≤—Ä–∞–≥–æ–≤ —Å–ª–∏—à–∫–æ–º –±–ª–∏–∑–∫–æ –∫ –∏–≥—Ä–æ–∫—É
                if (Math.abs(x) < 15 && Math.abs(z) < 15) continue;
                
                // –°–æ–∑–¥–∞–Ω–∏–µ –±–æ–ª–µ–µ –¥–µ—Ç–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω–æ–≥–æ –≤—Ä–∞–≥–∞
                const enemyGroup = new THREE.Group();
                
                // –¢–µ–ª–æ –≤—Ä–∞–≥–∞
                const bodyGeometry = new THREE.BoxGeometry(1.5, 2, 1);
                const bodyMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0xff0000,
                    roughness: 0.7,
                    metalness: 0.3,
                    map: textures.enemy
                });
                const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
                body.position.y = 1;
                body.castShadow = true;
                body.receiveShadow = true;
                enemyGroup.add(body);
                
                // –ì–æ–ª–æ–≤–∞ –≤—Ä–∞–≥–∞
                const headGeometry = new THREE.SphereGeometry(0.5, 16, 16);
                const headMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0xff5555,
                    roughness: 0.7,
                    metalness: 0.3
                });
                const head = new THREE.Mesh(headGeometry, headMaterial);
                head.position.y = 2.5;
                head.castShadow = true;
                head.receiveShadow = true;
                enemyGroup.add(head);
                
                // –†—É–∫–∏ –≤—Ä–∞–≥–∞
                const armGeometry = new THREE.CylinderGeometry(0.2, 0.2, 1.5, 8);
                const armMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0xdd0000,
                    roughness: 0.7,
                    metalness: 0.3
                });
                
                const leftArm = new THREE.Mesh(armGeometry, armMaterial);
                leftArm.position.set(-0.9, 1, 0);
                leftArm.rotation.z = Math.PI / 2;
                leftArm.castShadow = true;
                leftArm.receiveShadow = true;
                enemyGroup.add(leftArm);
                
                const rightArm = new THREE.Mesh(armGeometry, armMaterial);
                rightArm.position.set(0.9, 1, 0);
                rightArm.rotation.z = -Math.PI / 2;
                rightArm.castShadow = true;
                rightArm.receiveShadow = true;
                enemyGroup.add(rightArm);
                
                // –ù–æ–≥–∏ –≤—Ä–∞–≥–∞
                const legGeometry = new THREE.CylinderGeometry(0.25, 0.25, 1, 8);
                const legMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0xdd0000,
                    roughness: 0.7,
                    metalness: 0.3
                });
                
                const leftLeg = new THREE.Mesh(legGeometry, legMaterial);
                leftLeg.position.set(-0.5, -0.5, 0);
                leftLeg.castShadow = true;
                leftLeg.receiveShadow = true;
                enemyGroup.add(leftLeg);
                
                const rightLeg = new THREE.Mesh(legGeometry, legMaterial);
                rightLeg.position.set(0.5, -0.5, 0);
                rightLeg.castShadow = true;
                rightLeg.receiveShadow = true;
                enemyGroup.add(rightLeg);
                
                // –ü–æ–∑–∏—Ü–∏–æ–Ω–∏—Ä–æ–≤–∞–Ω–∏–µ –≤—Ä–∞–≥–∞
                enemyGroup.position.set(x, 0, z);
                
                // –î–æ–±–∞–≤–ª–µ–Ω–∏–µ —Å–≤–æ–π—Å—Ç–≤ –≤—Ä–∞–≥–∞
                enemyGroup.health = 100;
                enemyGroup.speed = ENEMY_SPEED_BASE * (1 + level * 0.1);
                enemyGroup.lastShot = 0;
                enemyGroup.shootInterval = 2000 - level * 100; // –ò–Ω—Ç–µ—Ä–≤–∞–ª —Å—Ç—Ä–µ–ª—å–±—ã —É–º–µ–Ω—å—à–∞–µ—Ç—Å—è —Å —É—Ä–æ–≤–Ω–µ–º
                if (enemyGroup.shootInterval < 500) enemyGroup.shootInterval = 500; // –ú–∏–Ω–∏–º–∞–ª—å–Ω—ã–π –∏–Ω—Ç–µ—Ä–≤–∞–ª
                
                // –î–æ–±–∞–≤–ª–µ–Ω–∏–µ –∫–æ–ª–ª–∞–π–¥–µ—Ä–∞ –¥–ª—è –≤—Ä–∞–≥–∞
                enemyGroup.collider = new THREE.Box3().setFromObject(enemyGroup);
                
                // –î–æ–±–∞–≤–ª–µ–Ω–∏–µ –≤—Ä–∞–≥–∞ –Ω–∞ —Å—Ü–µ–Ω—É
                scene.add(enemyGroup);
                enemies.push(enemyGroup);
                
                // –î–æ–±–∞–≤–ª–µ–Ω–∏–µ –Ω–µ–≤–∏–¥–∏–º–æ–≥–æ —Ö–µ–ª–ø–µ—Ä–∞ –¥–ª—è –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏—è –ø–æ–ø–∞–¥–∞–Ω–∏–π
                const helperGeometry = new THREE.BoxGeometry(1.5, 3, 1.5);
                const helperMaterial = new THREE.MeshBasicMaterial({ 
                    color: 0xff0000,
                    transparent: true,
                    opacity: 0.0 // –ù–µ–≤–∏–¥–∏–º—ã–π
                });
                const helper = new THREE.Mesh(helperGeometry, helperMaterial);
                helper.position.copy(enemyGroup.position);
                helper.position.y = 1.5;
                helper.enemyRef = enemyGroup; // –°—Å—ã–ª–∫–∞ –Ω–∞ –≤—Ä–∞–≥–∞
                scene.add(helper);
                enemyHelpers.push(helper);
            }
        }
        
        // –û–±—Ä–∞–±–æ—Ç–∫–∞ –Ω–∞–∂–∞—Ç–∏—è –∫–ª–∞–≤–∏—à - –ò–°–ü–†–ê–í–õ–ï–ù–û –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –¥–≤–∏–∂–µ–Ω–∏—è
        function onKeyDown(event) {
            if (gameOver || levelCompleted) return;
            
            switch (event.code) {
                case 'KeyW':
                case 'ArrowUp':
                    moveForward = true;  // –í–ø–µ—Ä–µ–¥ –ø—Ä–∏ –Ω–∞–∂–∞—Ç–∏–∏ W
                    break;
                case 'KeyS':
                case 'ArrowDown':
                    moveBackward = true;  // –ù–∞–∑–∞–¥ –ø—Ä–∏ –Ω–∞–∂–∞—Ç–∏–∏ S
                    break;
                case 'KeyA':
                case 'ArrowLeft':
                    moveLeft = true;  // –í–ª–µ–≤–æ –ø—Ä–∏ –Ω–∞–∂–∞—Ç–∏–∏ A
                    break;
                case 'KeyD':
                case 'ArrowRight':
                    moveRight = true;  // –í–ø—Ä–∞–≤–æ –ø—Ä–∏ –Ω–∞–∂–∞—Ç–∏–∏ D
                    break;
                case 'Space':
                    if (canJump) {
                        player.velocity.y = JUMP_FORCE;
                        canJump = false;
                    }
                    break;
                case 'ShiftLeft':
                case 'ShiftRight':
                    isRunning = true;
                    break;
                case 'KeyC':
                    isCrouching = !isCrouching;
                    if (isCrouching) {
                        player.position.y = 1;
                        camera.position.y = 0;
                    } else {
                        player.position.y = 2;
                        camera.position.y = 0;
                    }
                    break;
                case 'KeyR':
                    reload();
                    break;
            }
        }
        
        // –û–±—Ä–∞–±–æ—Ç–∫–∞ –æ—Ç–ø—É—Å–∫–∞–Ω–∏—è –∫–ª–∞–≤–∏—à
        function onKeyUp(event) {
            switch (event.code) {
                case 'KeyW':
                case 'ArrowUp':
                    moveForward = false;
                    break;
                case 'KeyS':
                case 'ArrowDown':
                    moveBackward = false;
                    break;
                case 'KeyA':
                case 'ArrowLeft':
                    moveLeft = false;
                    break;
                case 'KeyD':
                case 'ArrowRight':
                    moveRight = false;
                    break;
                case 'ShiftLeft':
                case 'ShiftRight':
                    isRunning = false;
                    break;
            }
        }
        
        // –û–±—Ä–∞–±–æ—Ç–∫–∞ –Ω–∞–∂–∞—Ç–∏—è –∫–Ω–æ–ø–∫–∏ –º—ã—à–∏
        function onMouseDown(event) {
            if (gameOver || levelCompleted) return;
            
            if (event.button === 0) { // –õ–µ–≤–∞—è –∫–Ω–æ–ø–∫–∞ –º—ã—à–∏
                isShooting = true;
                shoot();
            }
        }
        
        // –û–±—Ä–∞–±–æ—Ç–∫–∞ –æ—Ç–ø—É—Å–∫–∞–Ω–∏—è –∫–Ω–æ–ø–∫–∏ –º—ã—à–∏
        function onMouseUp(event) {
            if (event.button === 0) {
                isShooting = false;
            }
        }
        
        // –û–±—Ä–∞–±–æ—Ç–∫–∞ –±–ª–æ–∫–∏—Ä–æ–≤–∫–∏ —É–∫–∞–∑–∞—Ç–µ–ª—è –º—ã—à–∏
        function lockChangeAlert() {
            if (document.pointerLockElement === renderer.domElement) {
                document.addEventListener('mousemove', updateCamera, false);
            } else {
                document.removeEventListener('mousemove', updateCamera, false);
            }
        }
        
        // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –∫–∞–º–µ—Ä—ã –ø—Ä–∏ –¥–≤–∏–∂–µ–Ω–∏–∏ –º—ã—à–∏
        function updateCamera(event) {
            if (gameOver || levelCompleted) return;
            
            const movementX = event.movementX || event.mozMovementX || event.webkitMovementX || 0;
            const movementY = event.movementY || event.mozMovementY || event.webkitMovementY || 0;
            
            player.rotation.y -= movementX * 0.002;
            
            // –û–≥—Ä–∞–Ω–∏—á–µ–Ω–∏–µ –≤–µ—Ä—Ç–∏–∫–∞–ª—å–Ω–æ–≥–æ –≤—Ä–∞—â–µ–Ω–∏—è –∫–∞–º–µ—Ä—ã
            camera.rotation.x -= movementY * 0.002;
            camera.rotation.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, camera.rotation.x));
        }
        
        // –û–±—Ä–∞–±–æ—Ç–∫–∞ –∏–∑–º–µ–Ω–µ–Ω–∏—è —Ä–∞–∑–º–µ—Ä–∞ –æ–∫–Ω–∞
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        
        // –°–∏—Å—Ç–µ–º–∞ –∞–≤—Ç–æ–ø—Ä–∏—Ü–µ–ª–∏–≤–∞–Ω–∏—è
        function findTargetEnemy() {
            // –ù–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –≤–∑–≥–ª—è–¥–∞
            const lookDirection = new THREE.Vector3();
            camera.getWorldDirection(lookDirection);
            
            let closestEnemy = null;
            let closestAngle = AUTO_AIM_ANGLE;
            
            for (const helper of enemyHelpers) {
                // –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ –≤—Ä–∞–≥ –µ—â–µ –∂–∏–≤
                if (!helper.enemyRef || !scene.getObjectById(helper.enemyRef.id)) continue;
                
                // –í–µ–∫—Ç–æ—Ä –æ—Ç –∏–≥—Ä–æ–∫–∞ –∫ –≤—Ä–∞–≥—É
                const enemyDirection = new THREE.Vector3();
                enemyDirection.subVectors(helper.position, player.position).normalize();
                
                // –£–≥–æ–ª –º–µ–∂–¥—É –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–µ–º –≤–∑–≥–ª—è–¥–∞ –∏ –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–µ–º –∫ –≤—Ä–∞–≥—É
                const angle = lookDirection.angleTo(enemyDirection);
                
                // –†–∞—Å—Å—Ç–æ—è–Ω–∏–µ –¥–æ –≤—Ä–∞–≥–∞
                const distance = player.position.distanceTo(helper.position);
                
                // –ï—Å–ª–∏ –≤—Ä–∞–≥ –≤ –ø—Ä–µ–¥–µ–ª–∞—Ö —É–≥–ª–∞ –∞–≤—Ç–æ–ø—Ä–∏—Ü–µ–ª–∏–≤–∞–Ω–∏—è –∏ –Ω–µ —Å–ª–∏—à–∫–æ–º –¥–∞–ª–µ–∫–æ
                if (angle < closestAngle && distance < AUTO_AIM_DISTANCE) {
                    // –ü—Ä–æ–≤–µ—Ä–∫–∞ –≤–∏–¥–∏–º–æ—Å—Ç–∏ (–Ω–µ—Ç –ª–∏ —Å—Ç–µ–Ω –º–µ–∂–¥—É –∏–≥—Ä–æ–∫–æ–º –∏ –≤—Ä–∞–≥–æ–º)
                    raycaster.set(player.position, enemyDirection);
                    const intersects = raycaster.intersectObjects(walls);
                    
                    if (intersects.length === 0 || 
                        intersects[0].distance > distance) {
                        closestEnemy = helper;
                        closestAngle = angle;
                    }
                }
            }
            
            return closestEnemy;
        }
        
        // –°—Ç—Ä–µ–ª—å–±–∞
        function shoot() {
            if (reloading || ammo <= 0) {
                if (ammo <= 0) reload();
                return;
            }
            
            // –ù–∞–π—Ç–∏ —Ü–µ–ª—å –¥–ª—è –∞–≤—Ç–æ–ø—Ä–∏—Ü–µ–ª–∏–≤–∞–Ω–∏—è
            targetEnemy = findTargetEnemy();
            
            // –°–æ–∑–¥–∞–Ω–∏–µ –ø—É–ª–∏
            const bulletGeometry = new THREE.SphereGeometry(0.1, 8, 8);
            const bulletMaterial = new THREE.MeshBasicMaterial({ color: 0xffff00 });
            const bullet = new THREE.Mesh(bulletGeometry, bulletMaterial);
            
            // –ü–æ–∑–∏—Ü–∏–æ–Ω–∏—Ä–æ–≤–∞–Ω–∏–µ –ø—É–ª–∏ –ø–µ—Ä–µ–¥ –∏–≥—Ä–æ–∫–æ–º
            bullet.position.copy(player.position);
            bullet.position.y = camera.position.y;
            
            // –ù–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –ø—É–ª–∏
            let direction = new THREE.Vector3();
            
            if (targetEnemy) {
                // –ï—Å–ª–∏ –µ—Å—Ç—å —Ü–µ–ª—å, —Å—Ç—Ä–µ–ª—è–µ–º –≤ –Ω–µ–µ
                direction.subVectors(targetEnemy.position, player.position).normalize();
                
                // –î–æ–±–∞–≤–ª—è–µ–º –Ω–µ–±–æ–ª—å—à–æ–π —Ä–∞–∑–±—Ä–æ—Å –¥–ª—è —Ä–µ–∞–ª–∏—Å—Ç–∏—á–Ω–æ—Å—Ç–∏
                direction.x += (Math.random() - 0.5) * 0.02;
                direction.y += (Math.random() - 0.5) * 0.02;
                direction.z += (Math.random() - 0.5) * 0.02;
                direction.normalize();
                
                // –ü–æ–∫–∞–∑—ã–≤–∞–µ–º –º–∞—Ä–∫–µ—Ä –ø–æ–ø–∞–¥–∞–Ω–∏—è
                showHitMarker();
            } else {
                // –ò–Ω–∞—á–µ —Å—Ç—Ä–µ–ª—è–µ–º –≤ –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–∏ –∫–∞–º–µ—Ä—ã
                camera.getWorldDirection(direction);
            }
            
            bullet.velocity = direction.multiplyScalar(1);
            
            // –î–æ–±–∞–≤–ª–µ–Ω–∏–µ –ø—É–ª–∏ –Ω–∞ —Å—Ü–µ–Ω—É
            scene.add(bullet);
            bullets.push(bullet);
            
            // –°–æ–∑–¥–∞–Ω–∏–µ —ç—Ñ—Ñ–µ–∫—Ç–∞ –≤—Å–ø—ã—à–∫–∏ –≤—ã—Å—Ç—Ä–µ–ª–∞
            createMuzzleFlash();
            
            // –£–º–µ–Ω—å—à–µ–Ω–∏–µ –ø–∞—Ç—Ä–æ–Ω–æ–≤
            ammo--;
            document.getElementById('ammo-count').textContent = ammo;
            
            // –ó–≤—É–∫–æ–≤–æ–π —ç—Ñ—Ñ–µ–∫—Ç (–≤ —Ä–µ–∞–ª—å–Ω–æ–º –ø—Ä–æ–µ–∫—Ç–µ –¥–æ–±–∞–≤—å—Ç–µ –∑–≤—É–∫)
            // playSound('shoot');
        }
        
        // –°–æ–∑–¥–∞–Ω–∏–µ —ç—Ñ—Ñ–µ–∫—Ç–∞ –≤—Å–ø—ã—à–∫–∏ –≤—ã—Å—Ç—Ä–µ–ª–∞
        function createMuzzleFlash() {
            // –ü–æ–∑–∏—Ü–∏—è –≤—Å–ø—ã—à–∫–∏
            const muzzlePosition = new THREE.Vector3(0, 0, -1);
            muzzlePosition.applyQuaternion(camera.quaternion);
            muzzlePosition.add(camera.position);
            
            // –°–æ–∑–¥–∞–Ω–∏–µ —á–∞—Å—Ç–∏—Ü –¥–ª—è –≤—Å–ø—ã—à–∫–∏
            const particleCount = 20;
            const particleGeometry = new THREE.BufferGeometry();
            const particleMaterial = new THREE.PointsMaterial({
                color: 0xffff00,
                size: 0.1,
                transparent: true,
                opacity: 0.8
            });
            
            const positions = new Float32Array(particleCount * 3);
            const velocities = [];
            
            for (let i = 0; i < particleCount; i++) {
                // –°–ª—É—á–∞–π–Ω–æ–µ –ø–æ–ª–æ–∂–µ–Ω–∏–µ –≤–æ–∫—Ä—É–≥ —Ç–æ—á–∫–∏ –≤—Å–ø—ã—à–∫–∏
                const x = muzzlePosition.x + (Math.random() - 0.5) * 0.2;
                const y = muzzlePosition.y + (Math.random() - 0.5) * 0.2;
                const z = muzzlePosition.z + (Math.random() - 0.5) * 0.2;
                
                positions[i * 3] = x;
                positions[i * 3 + 1] = y;
                positions[i * 3 + 2] = z;
                
                // –°–ª—É—á–∞–π–Ω–∞—è —Å–∫–æ—Ä–æ—Å—Ç—å
                velocities.push(new THREE.Vector3(
                    (Math.random() - 0.5) * 0.1,
                    (Math.random() - 0.5) * 0.1,
                    (Math.random() - 0.5) * 0.1
                ));
            }
            
            particleGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            
            const particles = new THREE.Points(particleGeometry, particleMaterial);
            scene.add(particles);
            
            // –î–æ–±–∞–≤–ª–µ–Ω–∏–µ —Å–∏—Å—Ç–µ–º—ã —á–∞—Å—Ç–∏—Ü –¥–ª—è –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è
            particleSystems.push({
                particles: particles,
                velocities: velocities,
                life: 10 // –í—Ä–µ–º—è –∂–∏–∑–Ω–∏ —ç—Ñ—Ñ–µ–∫—Ç–∞ –≤ –∫–∞–¥—Ä–∞—Ö
            });
        }
        
        // –ü–æ–∫–∞–∑–∞—Ç—å –º–∞—Ä–∫–µ—Ä –ø–æ–ø–∞–¥–∞–Ω–∏—è
        function showHitMarker() {
            const hitMarker = document.getElementById('hit-marker');
            hitMarker.style.opacity = '1';
            
            setTimeout(() => {
                hitMarker.style.opacity = '0';
            }, 100);
        }
        
        // –ü–µ—Ä–µ–∑–∞—Ä—è–¥–∫–∞
        function reload() {
            if (reloading || ammo === maxAmmo) return;
            
            reloading = true;
            
            // –ü–æ–∫–∞–∑–∞—Ç—å –∏–Ω–¥–∏–∫–∞—Ç–æ—Ä –ø–µ—Ä–µ–∑–∞—Ä—è–¥–∫–∏
            document.getElementById('reload-indicator').style.display = 'block';
            
            setTimeout(() => {
                ammo = maxAmmo;
                document.getElementById('ammo-count').textContent = ammo;
                reloading = false;
                document.getElementById('reload-indicator').style.display = 'none';
            }, 2000);
        }
        
        // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –ø–æ–ª–æ—Å—ã –∑–¥–æ—Ä–æ–≤—å—è
        function updateHealthBar() {
            const healthFill = document.getElementById('health-fill');
            healthFill.style.width = health + '%';
            
            // –ò–∑–º–µ–Ω–µ–Ω–∏–µ —Ü–≤–µ—Ç–∞ –≤ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –æ—Ç –∑–¥–æ—Ä–æ–≤—å—è
            if (health > 60) {
                healthFill.style.backgroundColor = '#0f0';
            } else if (health > 30) {
                healthFill.style.backgroundColor = '#ff0';
            } else {
                healthFill.style.backgroundColor = '#f00';
            }
        }
        
        // –°–æ–∑–¥–∞–Ω–∏–µ —ç—Ñ—Ñ–µ–∫—Ç–∞ –ø–æ–ø–∞–¥–∞–Ω–∏—è
        function createHitEffect(position) {
            // –°–æ–∑–¥–∞–Ω–∏–µ —á–∞—Å—Ç–∏—Ü –¥–ª—è —ç—Ñ—Ñ–µ–∫—Ç–∞ –ø–æ–ø–∞–¥–∞–Ω–∏—è
            const particleCount = 30;
            const particleGeometry = new THREE.BufferGeometry();
            const particleMaterial = new THREE.PointsMaterial({
                color: 0xff0000,
                size: 0.1,
                transparent: true,
                opacity: 0.8
            });
            
            const positions = new Float32Array(particleCount * 3);
            const velocities = [];
            
            for (let i = 0; i < particleCount; i++) {
                // –ù–∞—á–∞–ª—å–Ω–æ–µ –ø–æ–ª–æ–∂–µ–Ω–∏–µ –≤ —Ç–æ—á–∫–µ –ø–æ–ø–∞–¥–∞–Ω–∏—è
                positions[i * 3] = position.x;
                positions[i * 3 + 1] = position.y;
                positions[i * 3 + 2] = position.z;
                
                // –°–ª—É—á–∞–π–Ω–∞—è —Å–∫–æ—Ä–æ—Å—Ç—å –≤–æ –≤—Å–µ —Å—Ç–æ—Ä–æ–Ω—ã
                const velocity = new THREE.Vector3(
                    (Math.random() - 0.5) * 0.2,
                    (Math.random() - 0.5) * 0.2,
                    (Math.random() - 0.5) * 0.2
                );
                velocity.normalize().multiplyScalar(0.1 + Math.random() * 0.1);
                velocities.push(velocity);
            }
            
            particleGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            
            const particles = new THREE.Points(particleGeometry, particleMaterial);
            scene.add(particles);
            
            // –î–æ–±–∞–≤–ª–µ–Ω–∏–µ —Å–∏—Å—Ç–µ–º—ã —á–∞—Å—Ç–∏—Ü –¥–ª—è –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è
            particleSystems.push({
                particles: particles,
                velocities: velocities,
                life: 20 // –í—Ä–µ–º—è –∂–∏–∑–Ω–∏ —ç—Ñ—Ñ–µ–∫—Ç–∞ –≤ –∫–∞–¥—Ä–∞—Ö
            });
        }
        
        // –û–±—Ä–∞–±–æ—Ç–∫–∞ –ø–æ–ø–∞–¥–∞–Ω–∏—è –ø—É–ª–∏ –≤–æ –≤—Ä–∞–≥–∞
        function hitEnemy(enemy, bulletIndex) {
            enemy.health -= 25;
            
            // –°–æ–∑–¥–∞–Ω–∏–µ —ç—Ñ—Ñ–µ–∫—Ç–∞ –ø–æ–ø–∞–¥–∞–Ω–∏—è
            createHitEffect(bullets[bulletIndex].position.clone());
            
            if (enemy.health <= 0) {
                // –°–æ–∑–¥–∞–Ω–∏–µ —ç—Ñ—Ñ–µ–∫—Ç–∞ —É–Ω–∏—á—Ç–æ–∂–µ–Ω–∏—è
                createExplosion(enemy.position.clone());
                
                // –£–¥–∞–ª–µ–Ω–∏–µ –≤—Ä–∞–≥–∞ —Å–æ —Å—Ü–µ–Ω—ã
                scene.remove(enemy);
                enemies.splice(enemies.indexOf(enemy), 1);
                
                // –£–¥–∞–ª–µ–Ω–∏–µ —Ö–µ–ª–ø–µ—Ä–∞
                for (let i = 0; i < enemyHelpers.length; i++) {
                    if (enemyHelpers[i].enemyRef === enemy) {
                        scene.remove(enemyHelpers[i]);
                        enemyHelpers.splice(i, 1);
                        break;
                    }
                }
                
                // –£–≤–µ–ª–∏—á–µ–Ω–∏–µ —Å—á–µ—Ç–∞
                score += 100;
                document.getElementById('score').textContent = score;
                
                // –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ –∑–∞–≤–µ—Ä—à–µ–Ω–∏–µ —É—Ä–æ–≤–Ω—è
                if (enemies.length === 0) {
                    levelComplete();
                }
            }
            
            // –£–¥–∞–ª–µ–Ω–∏–µ –ø—É–ª–∏
            scene.remove(bullets[bulletIndex]);
            bullets.splice(bulletIndex, 1);
        }
        
        // –°–æ–∑–¥–∞–Ω–∏–µ —ç—Ñ—Ñ–µ–∫—Ç–∞ –≤–∑—Ä—ã–≤–∞
        function createExplosion(position) {
            // –°–æ–∑–¥–∞–Ω–∏–µ —á–∞—Å—Ç–∏—Ü –¥–ª—è —ç—Ñ—Ñ–µ–∫—Ç–∞ –≤–∑—Ä—ã–≤–∞
            const particleCount = 100;
            const particleGeometry = new THREE.BufferGeometry();
            const particleMaterial = new THREE.PointsMaterial({
                color: 0xff5500,
                size: 0.2,
                transparent: true,
                opacity: 0.8
            });
            
            const positions = new Float32Array(particleCount * 3);
            const velocities = [];
            const colors = [];
            
            for (let i = 0; i < particleCount; i++) {
                // –ù–∞—á–∞–ª—å–Ω–æ–µ –ø–æ–ª–æ–∂–µ–Ω–∏–µ –≤ —Ç–æ—á–∫–µ –≤–∑—Ä—ã–≤–∞
                positions[i * 3] = position.x;
                positions[i * 3 + 1] = position.y;
                positions[i * 3 + 2] = position.z;
                
                // –°–ª—É—á–∞–π–Ω–∞—è —Å–∫–æ—Ä–æ—Å—Ç—å –≤–æ –≤—Å–µ —Å—Ç–æ—Ä–æ–Ω—ã
                const velocity = new THREE.Vector3(
                    (Math.random() - 0.5) * 2,
                    (Math.random() - 0.5) * 2,
                    (Math.random() - 0.5) * 2
                );
                velocity.normalize().multiplyScalar(0.1 + Math.random() * 0.2);
                velocities.push(velocity);
                
                // –°–ª—É—á–∞–π–Ω—ã–π —Ü–≤–µ—Ç –æ—Ç –∫—Ä–∞—Å–Ω–æ–≥–æ –¥–æ –∂–µ–ª—Ç–æ–≥–æ
                const color = new THREE.Color();
                color.setHSL(0.05 + Math.random() * 0.05, 1, 0.5 + Math.random() * 0.5);
                colors.push(color);
            }
            
            particleGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            
            const particles = new THREE.Points(particleGeometry, particleMaterial);
            scene.add(particles);
            
            // –î–æ–±–∞–≤–ª–µ–Ω–∏–µ —Å–∏—Å—Ç–µ–º—ã —á–∞—Å—Ç–∏—Ü –¥–ª—è –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è
            particleSystems.push({
                particles: particles,
                velocities: velocities,
                colors: colors,
                life: 40 // –í—Ä–µ–º—è –∂–∏–∑–Ω–∏ —ç—Ñ—Ñ–µ–∫—Ç–∞ –≤ –∫–∞–¥—Ä–∞—Ö
            });
        }
        
        // –û–±—Ä–∞–±–æ—Ç–∫–∞ –ø–æ–ø–∞–¥–∞–Ω–∏—è –ø—É–ª–∏ –≤ –∏–≥—Ä–æ–∫–∞
        function hitPlayer(bulletIndex) {
            health -= 10;
            updateHealthBar();
            
            // –°–æ–∑–¥–∞–Ω–∏–µ —ç—Ñ—Ñ–µ–∫—Ç–∞ –ø–æ–ø–∞–¥–∞–Ω–∏—è
            createHitEffect(enemyBullets[bulletIndex].position.clone());
            
                        // –£–¥–∞–ª–µ–Ω–∏–µ –ø—É–ª–∏
            scene.remove(enemyBullets[bulletIndex]);
            enemyBullets.splice(bulletIndex, 1);
            
            // –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ –∫–æ–Ω–µ—Ü –∏–≥—Ä—ã
            if (health <= 0) {
                endGame();
            }
        }
        
        // –ó–∞–≤–µ—Ä—à–µ–Ω–∏–µ —É—Ä–æ–≤–Ω—è
        function levelComplete() {
            levelCompleted = true;
            document.getElementById('new-level').textContent = level + 1;
            document.getElementById('level-up').style.display = 'block';
            
            document.getElementById('next-level-button').addEventListener('click', function() {
                level++;
                document.getElementById('level-up').style.display = 'none';
                levelCompleted = false;
                createLevel();
            });
        }
        
        // –ö–æ–Ω–µ—Ü –∏–≥—Ä—ã
        function endGame() {
            gameOver = true;
            document.getElementById('final-score').textContent = score;
            document.getElementById('game-over').style.display = 'block';
            
            if (!isMobile) {
                document.exitPointerLock();
            }
            
            document.getElementById('restart-button').addEventListener('click', function() {
                document.getElementById('game-over').style.display = 'none';
                gameOver = false;
                health = 100;
                score = 0;
                level = 1;
                createLevel();
            });
        }
        
        // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ —Å–∏—Å—Ç–µ–º —á–∞—Å—Ç–∏—Ü
        function updateParticleSystems() {
            for (let i = particleSystems.length - 1; i >= 0; i--) {
                const system = particleSystems[i];
                
                // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –ø–æ–∑–∏—Ü–∏–π —á–∞—Å—Ç–∏—Ü
                const positions = system.particles.geometry.attributes.position.array;
                
                for (let j = 0; j < positions.length / 3; j++) {
                    positions[j * 3] += system.velocities[j].x;
                    positions[j * 3 + 1] += system.velocities[j].y;
                    positions[j * 3 + 2] += system.velocities[j].z;
                    
                    // –î–æ–±–∞–≤–ª–µ–Ω–∏–µ –≥—Ä–∞–≤–∏—Ç–∞—Ü–∏–∏ –¥–ª—è –Ω–µ–∫–æ—Ç–æ—Ä—ã—Ö —ç—Ñ—Ñ–µ–∫—Ç–æ–≤
                    system.velocities[j].y -= 0.001;
                }
                
                system.particles.geometry.attributes.position.needsUpdate = true;
                
                // –£–º–µ–Ω—å—à–µ–Ω–∏–µ –≤—Ä–µ–º–µ–Ω–∏ –∂–∏–∑–Ω–∏
                system.life--;
                
                // –£–º–µ–Ω—å—à–µ–Ω–∏–µ –ø—Ä–æ–∑—Ä–∞—á–Ω–æ—Å—Ç–∏ —Å–æ –≤—Ä–µ–º–µ–Ω–µ–º
                system.particles.material.opacity = system.life / 40;
                
                // –£–¥–∞–ª–µ–Ω–∏–µ —Å–∏—Å—Ç–µ–º—ã –ø–æ—Å–ª–µ –æ–∫–æ–Ω—á–∞–Ω–∏—è –≤—Ä–µ–º–µ–Ω–∏ –∂–∏–∑–Ω–∏
                if (system.life <= 0) {
                    scene.remove(system.particles);
                    particleSystems.splice(i, 1);
                }
            }
        }
        
        // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –∫–æ–ª–ª–µ–∫—Ç–∏–±–ª–æ–≤
        function updateCollectibles() {
            for (let i = collectibles.length - 1; i >= 0; i--) {
                const collectible = collectibles[i];
                
                // –í—Ä–∞—â–µ–Ω–∏–µ –∫–æ–ª–ª–µ–∫—Ç–∏–±–ª–∞
                collectible.rotation.y += collectible.rotationSpeed;
                
                // –ü–æ–¥–ø—Ä—ã–≥–∏–≤–∞–Ω–∏–µ –∫–æ–ª–ª–µ–∫—Ç–∏–±–ª–∞
                collectible.floatProgress += collectible.floatDirection * collectible.floatSpeed;
                
                // –ò–∑–º–µ–Ω–µ–Ω–∏–µ –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏—è –¥–≤–∏–∂–µ–Ω–∏—è –ø—Ä–∏ –¥–æ—Å—Ç–∏–∂–µ–Ω–∏–∏ –≥—Ä–∞–Ω–∏—Ü
                if (Math.abs(collectible.floatProgress) >= collectible.floatHeight) {
                    collectible.floatDirection *= -1;
                }
                
                // –ü—Ä–∏–º–µ–Ω–µ–Ω–∏–µ –ø–æ–∑–∏—Ü–∏–∏ Y
                collectible.position.y = collectible.originalY + collectible.floatProgress;
                
                // –ü—Ä–æ–≤–µ—Ä–∫–∞ –∫–æ–ª–ª–∏–∑–∏–∏ —Å –∏–≥—Ä–æ–∫–æ–º
                const collectibleBox = new THREE.Box3().setFromObject(collectible);
                const playerBox = new THREE.Box3();
                
                playerBox.min.set(
                    player.position.x - 0.5,
                    player.position.y - (isCrouching ? 0.5 : 1),
                    player.position.z - 0.5
                );
                playerBox.max.set(
                    player.position.x + 0.5,
                    player.position.y + (isCrouching ? 0.5 : 1),
                    player.position.z + 0.5
                );
                
                if (collectibleBox.intersectsBox(playerBox)) {
                    // –û–±—Ä–∞–±–æ—Ç–∫–∞ –ø–æ–¥–±–æ—Ä–∞ –∫–æ–ª–ª–µ–∫—Ç–∏–±–ª–∞
                    collectItem(collectible);
                    
                    // –£–¥–∞–ª–µ–Ω–∏–µ –∫–æ–ª–ª–µ–∫—Ç–∏–±–ª–∞ —Å–æ —Å—Ü–µ–Ω—ã
                    scene.remove(collectible);
                    collectibles.splice(i, 1);
                }
            }
        }
        
        // –û–±—Ä–∞–±–æ—Ç–∫–∞ –ø–æ–¥–±–æ—Ä–∞ –∫–æ–ª–ª–µ–∫—Ç–∏–±–ª–∞
        function collectItem(collectible) {
            switch (collectible.collectibleType) {
                case 'key':
                    hasCollectibleKey = true;
                    // –°–æ–∑–¥–∞–Ω–∏–µ —ç—Ñ—Ñ–µ–∫—Ç–∞ –ø–æ–ª—É—á–µ–Ω–∏—è –∫–ª—é—á–∞
                    createCollectEffect(collectible.position.clone(), 0xffcc00);
                    break;
                case 'health':
                    health = Math.min(health + 25, 100);
                    updateHealthBar();
                    // –°–æ–∑–¥–∞–Ω–∏–µ —ç—Ñ—Ñ–µ–∫—Ç–∞ –ø–æ–ª—É—á–µ–Ω–∏—è –∑–¥–æ—Ä–æ–≤—å—è
                    createCollectEffect(collectible.position.clone(), 0x00ff00);
                    break;
                case 'ammo':
                    ammo = maxAmmo;
                    document.getElementById('ammo-count').textContent = ammo;
                    // –°–æ–∑–¥–∞–Ω–∏–µ —ç—Ñ—Ñ–µ–∫—Ç–∞ –ø–æ–ª—É—á–µ–Ω–∏—è –ø–∞—Ç—Ä–æ–Ω–æ–≤
                    createCollectEffect(collectible.position.clone(), 0xffff00);
                    break;
                default:
                    score += 50;
                    document.getElementById('score').textContent = score;
                    // –°–æ–∑–¥–∞–Ω–∏–µ —ç—Ñ—Ñ–µ–∫—Ç–∞ –ø–æ–ª—É—á–µ–Ω–∏—è –æ—á–∫–æ–≤
                    createCollectEffect(collectible.position.clone(), 0x00ffff);
            }
        }
        
        // –°–æ–∑–¥–∞–Ω–∏–µ —ç—Ñ—Ñ–µ–∫—Ç–∞ —Å–±–æ—Ä–∞ –ø—Ä–µ–¥–º–µ—Ç–∞
        function createCollectEffect(position, color) {
            // –°–æ–∑–¥–∞–Ω–∏–µ —á–∞—Å—Ç–∏—Ü –¥–ª—è —ç—Ñ—Ñ–µ–∫—Ç–∞ —Å–±–æ—Ä–∞
            const particleCount = 30;
            const particleGeometry = new THREE.BufferGeometry();
            const particleMaterial = new THREE.PointsMaterial({
                color: color,
                size: 0.2,
                transparent: true,
                opacity: 0.8
            });
            
            const positions = new Float32Array(particleCount * 3);
            const velocities = [];
            
            for (let i = 0; i < particleCount; i++) {
                // –ù–∞—á–∞–ª—å–Ω–æ–µ –ø–æ–ª–æ–∂–µ–Ω–∏–µ –≤ —Ç–æ—á–∫–µ —Å–±–æ—Ä–∞
                positions[i * 3] = position.x;
                positions[i * 3 + 1] = position.y;
                positions[i * 3 + 2] = position.z;
                
                // –°–ª—É—á–∞–π–Ω–∞—è —Å–∫–æ—Ä–æ—Å—Ç—å –≤–≤–µ—Ä—Ö –∏ –≤ —Å—Ç–æ—Ä–æ–Ω—ã
                const velocity = new THREE.Vector3(
                    (Math.random() - 0.5) * 0.1,
                    Math.random() * 0.2,
                    (Math.random() - 0.5) * 0.1
                );
                velocities.push(velocity);
            }
            
            particleGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            
            const particles = new THREE.Points(particleGeometry, particleMaterial);
            scene.add(particles);
            
            // –î–æ–±–∞–≤–ª–µ–Ω–∏–µ —Å–∏—Å—Ç–µ–º—ã —á–∞—Å—Ç–∏—Ü –¥–ª—è –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è
            particleSystems.push({
                particles: particles,
                velocities: velocities,
                life: 30 // –í—Ä–µ–º—è –∂–∏–∑–Ω–∏ —ç—Ñ—Ñ–µ–∫—Ç–∞ –≤ –∫–∞–¥—Ä–∞—Ö
            });
        }
        
        // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ —Å–µ–∫—Ä–µ—Ç–Ω—ã—Ö –¥–≤–µ—Ä–µ–π
        function updateSecretDoors() {
            if (hasCollectibleKey) {
                for (const door of secretDoors) {
                    if (!door.isOpen) {
                        // –û—Ç–∫—Ä—ã—Ç–∏–µ –¥–≤–µ—Ä–∏
                        door.isOpen = true;
                        
                        // –ê–Ω–∏–º–∞—Ü–∏—è –æ—Ç–∫—Ä—ã—Ç–∏—è –¥–≤–µ—Ä–∏ - –ø–ª–∞–≤–Ω–æ–µ –æ–ø—É—Å–∫–∞–Ω–∏–µ
                        const targetY = door.position.y - door.geometry.parameters.height;
                        const doorTween = {
                            y: door.position.y,
                            progress: 0
                        };
                        
                        // –°–æ–∑–¥–∞–µ–º –ø—Ä–æ—Å—Ç—É—é –∞–Ω–∏–º–∞—Ü–∏—é –≤–º–µ—Å—Ç–æ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è –±–∏–±–ª–∏–æ—Ç–µ–∫–∏ –∞–Ω–∏–º–∞—Ü–∏–∏
                        door.animation = {
                            startY: door.position.y,
                            targetY: targetY,
                            progress: 0,
                            speed: 0.02
                        };
                        
                        // –£–¥–∞–ª—è–µ–º –¥–≤–µ—Ä—å –∏–∑ –º–∞—Å—Å–∏–≤–∞ —Å—Ç–µ–Ω, —á—Ç–æ–±—ã –∏–≥—Ä–æ–∫ –º–æ–≥ –ø—Ä–æ–π—Ç–∏
                        const doorIndex = walls.indexOf(door);
                        if (doorIndex !== -1) {
                            walls.splice(doorIndex, 1);
                        }
                    }
                    
                    // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –∞–Ω–∏–º–∞—Ü–∏–∏ –æ—Ç–∫—Ä—ã—Ç–∏—è, –µ—Å–ª–∏ –æ–Ω–∞ –µ—Å—Ç—å
                    if (door.animation && door.animation.progress < 1) {
                        door.animation.progress += door.animation.speed;
                        if (door.animation.progress > 1) door.animation.progress = 1;
                        
                        const newY = door.animation.startY + (door.animation.targetY - door.animation.startY) * door.animation.progress;
                        door.position.y = newY;
                    }
                }
            }
        }
        
        // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –¥–≤–∏–∂—É—â–∏—Ö—Å—è –ø–ª–∞—Ç—Ñ–æ—Ä–º
        function updatePlatforms() {
            for (const platform of platforms) {
                if (platform.isMoving) {
                    platform.movementProgress += platform.movementDirection * platform.movementSpeed;
                    
                    if (Math.abs(platform.movementProgress) >= 1) {
                        platform.movementDirection *= -1;
                    }
                    
                    const newX = platform.startPosition.x + platform.rangeX * platform.movementProgress;
                    const newY = platform.startPosition.y + platform.rangeY * platform.movementProgress;
                    const newZ = platform.startPosition.z + platform.rangeZ * platform.movementProgress;
                    
                    platform.position.set(newX, newY, newZ);
                }
                
                if (platform.isRotating) {
                    platform.rotation.y += platform.rotationSpeed;
                }
            }
            
            // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –≤—Ä–∞—â–∞—é—â–∏—Ö—Å—è –ø—Ä–µ–ø—è—Ç—Å—Ç–≤–∏–π
            for (const wall of walls) {
                if (wall.isRotating) {
                    wall.rotation.y += wall.rotationSpeed;
                }
            }
        }
        
        // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –∫–æ–Ω—Ç—Ä–æ–ª—å–Ω—ã—Ö —Ç–æ—á–µ–∫
        function updateCheckpoints() {
            for (let i = 0; i < scene.children.length; i++) {
                const object = scene.children[i];
                
                if (object.isCheckpoint) {
                    object.rotation.y += 0.01;
                    
                    // –ü—Ä–æ–≤–µ—Ä–∫–∞, –Ω–∞—Ö–æ–¥–∏—Ç—Å—è –ª–∏ –∏–≥—Ä–æ–∫ –Ω–∞ —ç—Ç–æ–π –∫–æ–Ω—Ç—Ä–æ–ª—å–Ω–æ–π —Ç–æ—á–∫–µ
                    const distance = player.position.distanceTo(object.position);
                    
                    if (distance < 1.5 && currentCheckpoint !== object) {
                        currentCheckpoint = object;
                        
                        // –°–æ–∑–¥–∞–Ω–∏–µ —ç—Ñ—Ñ–µ–∫—Ç–∞ –∞–∫—Ç–∏–≤–∞—Ü–∏–∏ –∫–æ–Ω—Ç—Ä–æ–ª—å–Ω–æ–π —Ç–æ—á–∫–∏
                        createCheckpointEffect(object.position.clone());
                        
                        // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ —Å—á—ë—Ç–∞
                        score += 25;
                        document.getElementById('score').textContent = score;
                    }
                }
            }
        }
        
        // –°–æ–∑–¥–∞–Ω–∏–µ —ç—Ñ—Ñ–µ–∫—Ç–∞ –∞–∫—Ç–∏–≤–∞—Ü–∏–∏ –∫–æ–Ω—Ç—Ä–æ–ª—å–Ω–æ–π —Ç–æ—á–∫–∏
        function createCheckpointEffect(position) {
            // –°–æ–∑–¥–∞–Ω–∏–µ —á–∞—Å—Ç–∏—Ü –¥–ª—è —ç—Ñ—Ñ–µ–∫—Ç–∞ –∞–∫—Ç–∏–≤–∞—Ü–∏–∏
            const particleCount = 50;
            const particleGeometry = new THREE.BufferGeometry();
            const particleMaterial = new THREE.PointsMaterial({
                color: 0x00ffff,
                size: 0.2,
                transparent: true,
                opacity: 0.8
            });
            
            const positions = new Float32Array(particleCount * 3);
            const velocities = [];
            
            for (let i = 0; i < particleCount; i++) {
                // –ù–∞—á–∞–ª—å–Ω–æ–µ –ø–æ–ª–æ–∂–µ–Ω–∏–µ –≤ —Ç–æ—á–∫–µ –∞–∫—Ç–∏–≤–∞—Ü–∏–∏
                positions[i * 3] = position.x;
                positions[i * 3 + 1] = position.y;
                positions[i * 3 + 2] = position.z;
                
                // –°–ª—É—á–∞–π–Ω–∞—è —Å–∫–æ—Ä–æ—Å—Ç—å –≤–æ –≤—Å–µ —Å—Ç–æ—Ä–æ–Ω—ã
                const angle = (i / particleCount) * Math.PI * 2;
                const speed = 0.1;
                
                velocities.push(new THREE.Vector3(
                    Math.cos(angle) * speed,
                    0.05 + Math.random() * 0.1,
                    Math.sin(angle) * speed
                ));
            }
            
            particleGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            
            const particles = new THREE.Points(particleGeometry, particleMaterial);
            scene.add(particles);
            
            // –î–æ–±–∞–≤–ª–µ–Ω–∏–µ —Å–∏—Å—Ç–µ–º—ã —á–∞—Å—Ç–∏—Ü –¥–ª—è –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è
            particleSystems.push({
                particles: particles,
                velocities: velocities,
                life: 40 // –í—Ä–µ–º—è –∂–∏–∑–Ω–∏ —ç—Ñ—Ñ–µ–∫—Ç–∞ –≤ –∫–∞–¥—Ä–∞—Ö
            });
        }
        
        // –ì–ª–∞–≤–Ω—ã–π –∏–≥—Ä–æ–≤–æ–π —Ü–∏–∫–ª
        function animate() {
            requestAnimationFrame(animate);
            
            // –†–∞—Å—á–µ—Ç –≤—Ä–µ–º–µ–Ω–∏ –º–µ–∂–¥—É –∫–∞–¥—Ä–∞–º–∏ –¥–ª—è –ø–ª–∞–≤–Ω–æ–≥–æ –¥–≤–∏–∂–µ–Ω–∏—è
            deltaTime = clock.getDelta();
            
            if (!gameOver && !levelCompleted) {
                // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –ø–æ–∑–∏—Ü–∏–∏ –∏–≥—Ä–æ–∫–∞
                updatePlayer();
                
                // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –≤—Ä–∞–≥–æ–≤
                updateEnemies();
                
                // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –ø—É–ª—å
                updateBullets();
                
                // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –ø—É–ª—å –≤—Ä–∞–≥–æ–≤
                updateEnemyBullets();
                
                // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ —Å–∏—Å—Ç–µ–º —á–∞—Å—Ç–∏—Ü
                updateParticleSystems();
                
                // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –∫–æ–ª–ª–µ–∫—Ç–∏–±–ª–æ–≤
                updateCollectibles();
                
                // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ —Å–µ–∫—Ä–µ—Ç–Ω—ã—Ö –¥–≤–µ—Ä–µ–π
                updateSecretDoors();
                
                // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –¥–≤–∏–∂—É—â–∏—Ö—Å—è –ø–ª–∞—Ç—Ñ–æ—Ä–º
                updatePlatforms();
                
                // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –∫–æ–Ω—Ç—Ä–æ–ª—å–Ω—ã—Ö —Ç–æ—á–µ–∫
                updateCheckpoints();
                
                // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –∫–∞–º–µ—Ä—ã –¥–ª—è –º–æ–±–∏–ª—å–Ω—ã—Ö —É—Å—Ç—Ä–æ–π—Å—Ç–≤
                if (isMobile) {
                    updateMobileCamera();
                }
                
                // –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∞—è —Å—Ç—Ä–µ–ª—å–±–∞ –ø—Ä–∏ –∑–∞–∂–∞—Ç–æ–π –∫–Ω–æ–ø–∫–µ
                if (isShooting && !reloading && ammo > 0) {
                    shoot();
                }
            }
            
            // –†–µ–Ω–¥–µ—Ä–∏–Ω–≥ —Å—Ü–µ–Ω—ã
            renderer.render(scene, camera);
        }
        
        // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –∫–∞–º–µ—Ä—ã –¥–ª—è –º–æ–±–∏–ª—å–Ω—ã—Ö —É—Å—Ç—Ä–æ–π—Å—Ç–≤
        function updateMobileCamera() {
            if (touchLookPosition.x !== lastTouchLookPosition.x || 
                touchLookPosition.y !== lastTouchLookPosition.y) {
                
                const movementX = touchLookPosition.x - lastTouchLookPosition.x;
                const movementY = touchLookPosition.y - lastTouchLookPosition.y;
                
                player.rotation.y -= movementX * 0.01;
                
                // –û–≥—Ä–∞–Ω–∏—á–µ–Ω–∏–µ –≤–µ—Ä—Ç–∏–∫–∞–ª—å–Ω–æ–≥–æ –≤—Ä–∞—â–µ–Ω–∏—è –∫–∞–º–µ—Ä—ã
                camera.rotation.x -= movementY * 0.01;
                camera.rotation.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, camera.rotation.x));
                
                lastTouchLookPosition.x = touchLookPosition.x;
                lastTouchLookPosition.y = touchLookPosition.y;
            }
        }
        
        // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –ø–æ–∑–∏—Ü–∏–∏ –∏–≥—Ä–æ–∫–∞
        function updatePlayer() {
            // –ì—Ä–∞–≤–∏—Ç–∞—Ü–∏—è
            player.velocity.y -= GRAVITY;
            
            // –ü—Ä–æ–≤–µ—Ä–∫–∞ —Å—Ç–æ–ª–∫–Ω–æ–≤–µ–Ω–∏—è —Å –ø–æ–ª–æ–º
            if (player.position.y < (isCrouching ? 1 : 2)) {
                player.position.y = isCrouching ? 1 : 2;
                player.velocity.y = 0;
                canJump = true;
            }
            
            // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –ø–æ–∑–∏—Ü–∏–∏ –ø–æ –≤–µ—Ä—Ç–∏–∫–∞–ª–∏
            player.position.y += player.velocity.y;
            
            // –†–∞—Å—á–µ—Ç –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏—è –¥–≤–∏–∂–µ–Ω–∏—è
            const speed = isRunning ? RUNNING_SPEED : PLAYER_SPEED;
            
            if (isMobile) {
                // –î–ª—è –º–æ–±–∏–ª—å–Ω—ã—Ö —É—Å—Ç—Ä–æ–π—Å—Ç–≤ –∏—Å–ø–æ–ª—å–∑—É–µ–º –∑–Ω–∞—á–µ–Ω–∏—è –¥–∂–æ–π—Å—Ç–∏–∫–∞ - –ò–°–ü–†–ê–í–õ–ï–ù–û
                player.direction.z = -joystickPosition.y; // –ò–Ω–≤–µ—Ä—Ç–∏—Ä–æ–≤–∞–Ω–Ω–∞—è –æ—Å—å Y –¥–ª—è –ø—Ä–∞–≤–∏–ª—å–Ω–æ–≥–æ –¥–≤–∏–∂–µ–Ω–∏—è
                player.direction.x = joystickPosition.x;
            } else {
                // –î–ª—è –ü–ö –∏—Å–ø–æ–ª—å–∑—É–µ–º –∫–ª–∞–≤–∏—à–∏ - –ò–°–ü–†–ê–í–õ–ï–ù–û –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–µ
                player.direction.z = Number(moveForward) - Number(moveBackward);
                player.direction.x = Number(moveRight) - Number(moveLeft);
            }
            
            player.direction.normalize();
            
            // –ü—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏–µ –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏—è –≤ —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤–∏–∏ —Å –ø–æ–≤–æ—Ä–æ—Ç–æ–º –∏–≥—Ä–æ–∫–∞
            if (player.direction.z !== 0) {
                player.velocity.z = player.direction.z * speed;
            }
            if (player.direction.x !== 0) {
                player.velocity.x = player.direction.x * speed;
            }
            
            // –ï—Å–ª–∏ –Ω–µ—Ç –¥–≤–∏–∂–µ–Ω–∏—è, –ø–æ—Å—Ç–µ–ø–µ–Ω–Ω–æ –∑–∞–º–µ–¥–ª—è–µ–º
            if (player.direction.z === 0) {
                player.velocity.z *= 0.9;
            }
            if (player.direction.x === 0) {
                player.velocity.x *= 0.9;
            }
            
            // –í—Ä–∞—â–µ–Ω–∏–µ –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏—è –≤ —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤–∏–∏ —Å –ø–æ–≤–æ—Ä–æ—Ç–æ–º –∏–≥—Ä–æ–∫–∞
            const rotatedVelocity = player.velocity.clone();
            rotatedVelocity.applyAxisAngle(new THREE.Vector3(0, 1, 0), player.rotation.y);
            
            // –ü—Ä–æ–≤–µ—Ä–∫–∞ –∫–æ–ª–ª–∏–∑–∏–π –ø–µ—Ä–µ–¥ –¥–≤–∏–∂–µ–Ω–∏–µ–º
            const nextPosition = player.position.clone();
            nextPosition.x += rotatedVelocity.x;
            nextPosition.z += rotatedVelocity.z;
            
            // –ü—Ä–æ–≤–µ—Ä–∫–∞ —Å—Ç–æ–ª–∫–Ω–æ–≤–µ–Ω–∏–π —Å–æ —Å—Ç–µ–Ω–∞–º–∏
            let canMove = true;
            
            for (const wall of walls) {
                const playerBox = new THREE.Box3().setFromObject(
                    new THREE.Mesh(
                        new THREE.BoxGeometry(1, isCrouching ? 1 : 2, 1),
                        new THREE.MeshBasicMaterial()
                    )
                );
                playerBox.min.set(
                    nextPosition.x - 0.5,
                    nextPosition.y - (isCrouching ? 0.5 : 1),
                    nextPosition.z - 0.5
                );
                playerBox.max.set(
                    nextPosition.x + 0.5,
                    nextPosition.y + (isCrouching ? 0.5 : 1),
                    nextPosition.z + 0.5
                );
                
                const wallBox = new THREE.Box3().setFromObject(wall);
                
                if (playerBox.intersectsBox(wallBox)) {
                    canMove = false;
                    break;
                }
            }
            
            // –ü—Ä–∏–º–µ–Ω–µ–Ω–∏–µ –¥–≤–∏–∂–µ–Ω–∏—è, –µ—Å–ª–∏ –Ω–µ—Ç –∫–æ–ª–ª–∏–∑–∏–π
            if (canMove) {
                player.position.x += rotatedVelocity.x;
                player.position.z += rotatedVelocity.z;
            }
            
            // –ü—Ä–æ–≤–µ—Ä–∫–∞ –ø–∞–¥–µ–Ω–∏—è –≤ –ø—Ä–æ–ø–∞—Å—Ç—å
            if (player.position.y < -10) {
                // –í–æ–∑–≤—Ä–∞—Ç –Ω–∞ –∫–æ–Ω—Ç—Ä–æ–ª—å–Ω—É—é —Ç–æ—á–∫—É –∏–ª–∏ –Ω–∞—á–∞–ª—å–Ω—É—é –ø–æ–∑–∏—Ü–∏—é
                if (currentCheckpoint) {
                    player.position.set(
                        currentCheckpoint.position.x,
                        currentCheckpoint.position.y + 2,
                        currentCheckpoint.position.z
                    );
                } else {
                    player.position.set(0, 2, 0);
                }
                player.velocity.set(0, 0, 0);
                
                // –£–º–µ–Ω—å—à–µ–Ω–∏–µ –∑–¥–æ—Ä–æ–≤—å—è –∑–∞ –ø–∞–¥–µ–Ω–∏–µ
                health -= 20;
                updateHealthBar();
                
                if (health <= 0) {
                    endGame();
                }
            }
        }
        
        // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –≤—Ä–∞–≥–æ–≤
        function updateEnemies() {
            const now = Date.now();
            
            for (let i = 0; i < enemies.length; i++) {
                const enemy = enemies[i];
                
                // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ —Ö–µ–ª–ø–µ—Ä–∞
                for (const helper of enemyHelpers) {
                    if (helper.enemyRef === enemy) {
                        helper.position.copy(enemy.position);
                        helper.position.y = 1.5;
                        break;
                    }
                }
                
                // –ù–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –∫ –∏–≥—Ä–æ–∫—É
                const direction = new THREE.Vector3();
                direction.subVectors(player.position, enemy.position).normalize();
                
                // –ü—Ä–æ–≤–µ—Ä–∫–∞ –≤–∏–¥–∏–º–æ—Å—Ç–∏ –∏–≥—Ä–æ–∫–∞
                raycaster.set(enemy.position, direction);
                const intersects = raycaster.intersectObjects(walls);
                
                // –ï—Å–ª–∏ –º–µ–∂–¥—É –≤—Ä–∞–≥–æ–º –∏ –∏–≥—Ä–æ–∫–æ–º –Ω–µ—Ç —Å—Ç–µ–Ω
                if (intersects.length === 0 || 
                    intersects[0].distance > enemy.position.distanceTo(player.position)) {
                    
                    // –î–≤–∏–∂–µ–Ω–∏–µ –∫ –∏–≥—Ä–æ–∫—É
                    const newPosition = enemy.position.clone();
                    newPosition.x += direction.x * enemy.speed;
                    newPosition.z += direction.z * enemy.speed;
                    
                    // –ü—Ä–æ–≤–µ—Ä–∫–∞ –∫–æ–ª–ª–∏–∑–∏–π
                    let canMove = true;
                    
                    for (const wall of walls) {
                        const enemyBox = new THREE.Box3().setFromObject(
                            new THREE.Mesh(
                                new THREE.BoxGeometry(1.5, 3, 1.5),
                                new THREE.MeshBasicMaterial()
                            )
                        );
                        enemyBox.min.set(
                            newPosition.x - 0.75,
                            newPosition.y - 1.5,
                            newPosition.z - 0.75
                        );
                        enemyBox.max.set(
                            newPosition.x + 0.75,
                            newPosition.y + 1.5,
                            newPosition.z + 0.75
                        );
                        
                        const wallBox = new THREE.Box3().setFromObject(wall);
                        
                        if (enemyBox.intersectsBox(wallBox)) {
                            canMove = false;
                            break;
                        }
                    }
                    
                    // –ü—Ä–∏–º–µ–Ω–µ–Ω–∏–µ –¥–≤–∏–∂–µ–Ω–∏—è, –µ—Å–ª–∏ –Ω–µ—Ç –∫–æ–ª–ª–∏–∑–∏–π
                    if (canMove) {
                        enemy.position.copy(newPosition);
                    }
                    
                    // –ü–æ–≤–æ—Ä–æ—Ç –≤—Ä–∞–≥–∞ –∫ –∏–≥—Ä–æ–∫—É
                    enemy.lookAt(player.position);
                    
                    // –°—Ç—Ä–µ–ª—å–±–∞ –≤ –∏–≥—Ä–æ–∫–∞
                    if (now - enemy.lastShot > enemy.shootInterval) {
                        enemyShoot(enemy);
                        enemy.lastShot = now;
                    }
                }
                
                // –ê–Ω–∏–º–∞—Ü–∏—è –≤—Ä–∞–≥–∞ (–ø–æ–∫–∞—á–∏–≤–∞–Ω–∏–µ)
                enemy.position.y = Math.sin(now * 0.003 + i) * 0.1;
                
                // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –∫–æ–ª–ª–∞–π–¥–µ—Ä–∞
                enemy.collider = new THREE.Box3().setFromObject(enemy);
            }
        }
        
        // –°—Ç—Ä–µ–ª—å–±–∞ –≤—Ä–∞–≥–∞
        function enemyShoot(enemy) {
            // –°–æ–∑–¥–∞–Ω–∏–µ –ø—É–ª–∏
            const bulletGeometry = new THREE.SphereGeometry(0.1, 8, 8);
            const bulletMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000 });
            const bullet = new THREE.Mesh(bulletGeometry, bulletMaterial);
            
            // –ü–æ–∑–∏—Ü–∏–æ–Ω–∏—Ä–æ–≤–∞–Ω–∏–µ –ø—É–ª–∏
            bullet.position.copy(enemy.position);
            bullet.position.y = 1.5;
            
            // –ù–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –ø—É–ª–∏ –≤ –∏–≥—Ä–æ–∫–∞
            const direction = new THREE.Vector3();
            direction.subVectors(player.position, enemy.position).normalize();
            
            // –î–æ–±–∞–≤–ª–µ–Ω–∏–µ –Ω–µ–±–æ–ª—å—à–æ–≥–æ —Ä–∞–∑–±—Ä–æ—Å–∞
            direction.x += (Math.random() - 0.5) * 0.1;
            direction.y += (Math.random() - 0.5) * 0.1;
            direction.z += (Math.random() - 0.5) * 0.1;
            direction.normalize();
            
            bullet.velocity = direction.multiplyScalar(0.7);
            
            // –°–æ–∑–¥–∞–Ω–∏–µ —ç—Ñ—Ñ–µ–∫—Ç–∞ –≤—Å–ø—ã—à–∫–∏ –≤—ã—Å—Ç—Ä–µ–ª–∞
            createMuzzleFlash();
            
            // –î–æ–±–∞–≤–ª–µ–Ω–∏–µ –ø—É–ª–∏ –Ω–∞ —Å—Ü–µ–Ω—É
            scene.add(bullet);
            enemyBullets.push(bullet);
        }
        
        // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –ø—É–ª—å
        function updateBullets() {
            for (let i = bullets.length - 1; i >= 0; i--) {
                const bullet = bullets[i];
                
                // –ü–µ—Ä–µ–º–µ—â–µ–Ω–∏–µ –ø—É–ª–∏
                bullet.position.add(bullet.velocity);
                
                // –ü—Ä–æ–≤–µ—Ä–∫–∞ –∫–æ–ª–ª–∏–∑–∏–π —Å –≤—Ä–∞–≥–∞–º–∏
                for (let j = 0; j < enemyHelpers.length; j++) {
                    const helper = enemyHelpers[j];
                    
                    const bulletBox = new THREE.Box3().setFromObject(bullet);
                    const enemyBox = new THREE.Box3().setFromObject(helper);
                    
                    if (bulletBox.intersectsBox(enemyBox)) {
                        hitEnemy(helper.enemyRef, i);
                        // –í—ã—Ö–æ–¥ –∏–∑ —Ü–∏–∫–ª–∞, —Ç–∞–∫ –∫–∞–∫ –ø—É–ª—è —É–∂–µ —É–¥–∞–ª–µ–Ω–∞
                        break;
                    }
                }
                
                // –ï—Å–ª–∏ –ø—É–ª—è –≤—Å–µ –µ—â–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç, –ø—Ä–æ–≤–µ—Ä—è–µ–º –∫–æ–ª–ª–∏–∑–∏–∏ —Å–æ —Å—Ç–µ–Ω–∞–º–∏
                if (i < bullets.length) {
                    // –ü—Ä–æ–≤–µ—Ä–∫–∞ –∫–æ–ª–ª–∏–∑–∏–π —Å–æ —Å—Ç–µ–Ω–∞–º–∏
                    for (const wall of walls) {
                        const bulletBox = new THREE.Box3().setFromObject(bullet);
                        const wallBox = new THREE.Box3().setFromObject(wall);
                        
                        if (bulletBox.intersectsBox(wallBox)) {
                            // –°–æ–∑–¥–∞–Ω–∏–µ —ç—Ñ—Ñ–µ–∫—Ç–∞ –ø–æ–ø–∞–¥–∞–Ω–∏—è –≤ —Å—Ç–µ–Ω—É
                            createHitEffect(bullet.position.clone());
                            
                            scene.remove(bullet);
                            bullets.splice(i, 1);
                            break;
                        }
                    }
                }
                
                // –£–¥–∞–ª–µ–Ω–∏–µ –ø—É–ª—å, –∫–æ—Ç–æ—Ä—ã–µ —É–ª–µ—Ç–µ–ª–∏ —Å–ª–∏—à–∫–æ–º –¥–∞–ª–µ–∫–æ
                if (i < bullets.length && bullet.position.distanceTo(player.position) > 100) {
                    scene.remove(bullet);
                    bullets.splice(i, 1);
                }
            }
        }
        
        // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –ø—É–ª—å –≤—Ä–∞–≥–æ–≤
        function updateEnemyBullets() {
            for (let i = enemyBullets.length - 1; i >= 0; i--) {
                const bullet = enemyBullets[i];
                
                // –ü–µ—Ä–µ–º–µ—â–µ–Ω–∏–µ –ø—É–ª–∏
                bullet.position.add(bullet.velocity);
                
                // –ü—Ä–æ–≤–µ—Ä–∫–∞ –∫–æ–ª–ª–∏–∑–∏–π —Å –∏–≥—Ä–æ–∫–æ–º
                const bulletBox = new THREE.Box3().setFromObject(bullet);
                const playerBox = new THREE.Box3();
                
                playerBox.min.set(
                    player.position.x - 0.5,
                    player.position.y - (isCrouching ? 0.5 : 1),
                    player.position.z - 0.5
                );
                playerBox.max.set(
                    player.position.x + 0.5,
                    player.position.y + (isCrouching ? 0.5 : 1),
                    player.position.z + 0.5
                );
                
                if (bulletBox.intersectsBox(playerBox)) {
                    hitPlayer(i);
                    continue;
                }
                
                // –ü—Ä–æ–≤–µ—Ä–∫–∞ –∫–æ–ª–ª–∏–∑–∏–π —Å–æ —Å—Ç–µ–Ω–∞–º–∏
                for (const wall of walls) {
                    const wallBox = new THREE.Box3().setFromObject(wall);
                    
                    if (bulletBox.intersectsBox(wallBox)) {
                        // –°–æ–∑–¥–∞–Ω–∏–µ —ç—Ñ—Ñ–µ–∫—Ç–∞ –ø–æ–ø–∞–¥–∞–Ω–∏—è –≤ —Å—Ç–µ–Ω—É
                        createHitEffect(bullet.position.clone());
                        
                        scene.remove(bullet);
                        enemyBullets.splice(i, 1);
                        break;
                    }
                }
                
                // –£–¥–∞–ª–µ–Ω–∏–µ –ø—É–ª—å, –∫–æ—Ç–æ—Ä—ã–µ —É–ª–µ—Ç–µ–ª–∏ —Å–ª–∏—à–∫–æ–º –¥–∞–ª–µ–∫–æ
                if (i < enemyBullets.length && bullet.position.distanceTo(player.position) > 100) {
                    scene.remove(bullet);
                    enemyBullets.splice(i, 1);
                }
            }
        }
    </script>
</body>
</html>
